<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://yamakarov.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="http://yamakarov.ru/" rel="alternate" type="text/html" /><updated>2018-09-07T15:35:02+03:00</updated><id>http://yamakarov.ru/</id><title type="html">Записки Java программиста</title><subtitle>Блог о разработке web админок, CRM-ок и прочего. 
</subtitle><entry><title type="html">Что такое корректность программы?</title><link href="http://yamakarov.ru/software/2018/09/07/programm-proof.html" rel="alternate" type="text/html" title="Что такое корректность программы?" /><published>2018-09-07T15:03:00+03:00</published><updated>2018-09-07T15:03:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/07/programm-proof</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/07/programm-proof.html">&lt;p&gt;В одном из своих &lt;a href=&quot;/cs/2018/08/10/program-proofs.html&quot;&gt;постов&lt;/a&gt; я упоминал, что считаю доказательство корректности программы перспективным методом ускорения разработки за счет устранения ошибок, уменьшения времени отлаживания программы и снижения издержек во время эксплуатации за счет уменьшения числа найденных ошибок после запуска.&lt;/p&gt;

&lt;p&gt;На практике доказывать программы оказывается довольно непривычно.
Для этого нужно понять, что мы хотим доказать.
Формулировка: Мы хотим доказать, что программа работает правильно, является крайне расплывчатой.
Не помогает заменить правильность на отсутствие ошибок, так как это, очевидно, тавтология.&lt;/p&gt;

&lt;p&gt;Чтобы что-то доказать, мы должны сформулировать теоремы, которые собственно и будем доказывать.&lt;/p&gt;

&lt;p&gt;Я встречался в статьях со следующими формулировками:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Доказать, что цикл завершается у Дейкстры&lt;/li&gt;
  &lt;li&gt;Доказательство, что определенная формула верна, например частное умножить на делитель плюс остаток равно исходному числу у Хоара&lt;/li&gt;
  &lt;li&gt;Доказательство свойства взаимного исключения, отсутствия дедлоков и живучести алгоритмов синхронизации у Лампорта&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Таким образом, когда у нас есть определенная программа мы должны определить интересные нам свойства и доказать, что они выполняются.
В этом плане довольно просто доказывать функции без побочных эффектов.
Нам надо чтобы за конечное число шагов такая функция получила результат, а значит надо доказать:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Асимптотику выполнения программы, за О каких шагов выполнится алгоритм&lt;/li&gt;
  &lt;li&gt;Доказать, что выходные значения будут удовлетворять некоторой формуле, входит в какие-то множества и так далее&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Программы с побочными эффектами будут несколько сложнее, но кажется если в исходные параметры и в результаты добавить внешнюю систему, то можно доказывать тоже самое.&lt;/p&gt;</content><author><name></name></author><summary type="html">В одном из своих постов я упоминал, что считаю доказательство корректности программы перспективным методом ускорения разработки за счет устранения ошибок, уменьшения времени отлаживания программы и снижения издержек во время эксплуатации за счет уменьшения числа найденных ошибок после запуска.</summary></entry><entry><title type="html">Один за всех</title><link href="http://yamakarov.ru/software/2018/09/06/laguage.html" rel="alternate" type="text/html" title="Один за всех" /><published>2018-09-06T19:18:00+03:00</published><updated>2018-09-06T19:18:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/06/laguage</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/06/laguage.html">&lt;p&gt;У меня есть смутное подозрение, что использование одного языка для написания проекта является большим благом.
Когда разработчику приходится разбираться в коде на нескольких языках он теряется.
Гораздо проще и понятнее работать с идиомами одного языка.
И в этом плане мне очень понравилось писать на Clojure.
Я верстал страницы и делал серверные обработчики на одном языке.
Фронтенд пришлось писать на других языках, но это была моя слабость.
Он вообще славится полифонией языков, html, css, javascript и т.д.&lt;/p&gt;

&lt;p&gt;Не понимаю почему так произошло, но мне кажется это неправильный путь.
Гораздо лучше писать на одном языке.
При этом может возникнуть проблема.
В разных средах исполнения у языка будет разная семантика, но я думаю как раз это некритично.&lt;/p&gt;

&lt;p&gt;Я не хочу использовать Clojure, потому что это язык без статической проверки типов.
Мне кажется в большой командной разработке обязательно использовать по крайней мере строго типизированный язык.&lt;/p&gt;

&lt;p&gt;Некоторые используют Haskell и OCaml. 
Но я пытался и пришел к выводу, что они слишком академичные и не готовы к промышленному использованию.
Да иногда получается сделать на них очень хорошие вещи, но для этого нужен подлинный энтузиаст, который готов несмотря ни на что фиксить проблемы использования языка.&lt;/p&gt;

&lt;p&gt;Опять же таки в Haskell, очень много заумных идей и заумное сообщество, из-за чего программирование на нем превращается в непрерывное увлекательное чтение статей с переднего края разработки языков.
Я не знаю к сожалению C и С++, они имеют свою область применения. Мне гораздо ближе Java.&lt;/p&gt;

&lt;p&gt;Java слишком многословна, и GWT которым можно было компилировать Java в Javascript провалился. 
Больно долго он это делал и имел плохую интеграцию с браузерами.&lt;/p&gt;

&lt;p&gt;В качестве конкурента Java на мой взгляд выступает только Kotlin, который активно развивается и имеет хорошую поддержку от JetBrains.
Это интересный язык, но я пока так и не смог найти очевидные преимущества Kotlin в выразительной силе перед Java.&lt;/p&gt;</content><author><name></name></author><summary type="html">У меня есть смутное подозрение, что использование одного языка для написания проекта является большим благом. Когда разработчику приходится разбираться в коде на нескольких языках он теряется. Гораздо проще и понятнее работать с идиомами одного языка. И в этом плане мне очень понравилось писать на Clojure. Я верстал страницы и делал серверные обработчики на одном языке. Фронтенд пришлось писать на других языках, но это была моя слабость. Он вообще славится полифонией языков, html, css, javascript и т.д.</summary></entry><entry><title type="html">Погружаемся! Где остановиться, когда идешь на дно?</title><link href="http://yamakarov.ru/software/2018/09/05/go-deeper.html" rel="alternate" type="text/html" title="Погружаемся! Где остановиться, когда идешь на дно?" /><published>2018-09-05T11:20:00+03:00</published><updated>2018-09-05T11:20:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/05/go-deeper</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/05/go-deeper.html">&lt;p&gt;Программное обеспечение состоит из &lt;a href=&quot;/architecture/2018/08/20/layer-architecture.html&quot;&gt;слоев&lt;/a&gt;. 
Каждый слой имеет определенный интерфейс.
Когда мы используем интерфейс и встречаемся с ошибкой в этом интерфейсе, мы должны разобраться в реализации и опуститься на слой ниже.
Даже если нет никаких ошибок, есть определенные ограничения.
Они лежат за пределами интерфейса текущего уровня.&lt;/p&gt;

&lt;p&gt;Чтобы понимать эти ограничения надо опускаться на уровень ниже. 
Например в нашем web-приложении мы ограничены в числе запросов обрабатываемых в секунду времени.
Тогда нам нужно разбираться со Spring, чтобы увеличить это количество. 
Spring это для примера, на его место не умоляя общности можно поставить любую другую надстройку над http сервером.
Когда мы выжали все что можно из наших сервлетов и Spring, нам нужно оптимизировать http сервер.
Если с сервером мы тоже справились, можно идти дальше и разбираться с системными вызовами к сетевому оборудованию, с работой с сокетами.
Когда на уровне сокетов мы выжали все что можем в операционной системе, мы можем улучшить физические сетевые адаптеры.
Разобравшись с сетевыми картами, мы можем изменить разобраться с физикой процессов передачи информации и сделать оптоволоконные кабели, вместо медных и заменить процессоры.
В физике, можно опускаться еще ниже и ниже, до ядерной и квантовой физики для создания выдающихся новых технологий.&lt;/p&gt;

&lt;p&gt;На моем опыте, средним по силе программист считается, если хорошо разбирается в коде своего уровня и умеет опускаться хотя бы на уровень ниже.
Более менее сильным программист становится, если доходит до двух трех уровней вниз, где-то до базовых протоколов взаимодействия. 
Http в моем случае.
Классным специалист считается, когда он знает досконально все начиная с инферфейса железа, далее операционной системы и далее.
Может оттрейсить выполнение алгоритма до машинных команд.&lt;/p&gt;

&lt;p&gt;Дальше в принципе уже достаточно общего понимания физики транзисторов и их работы, чтобы хорошо программировать, на мой взгляд не надо уметь проектировать процессоры.
Программирование и разводка микросхем ортогональные навыки.
Может быть это потому, что я не работал в компаниях уровня Google.&lt;/p&gt;

&lt;p&gt;Там ребята для обучения AlphaGo  запилили собственный кластер, ПО для этого кластера и специализированные TPU устройства для обучения нейронных сетей. И это очень круто, особенно учитывая что развитие процессоров общего назначения остановилось.
И в будущем будет расти число узкоспециализированных устройств, проектирование которых будет упрощаться и время от проекта до использования уменьшаться. 
Особенно показателен в этом плане приме Asic устройств для майнинга биткоинов.&lt;/p&gt;</content><author><name></name></author><summary type="html">Программное обеспечение состоит из слоев. Каждый слой имеет определенный интерфейс. Когда мы используем интерфейс и встречаемся с ошибкой в этом интерфейсе, мы должны разобраться в реализации и опуститься на слой ниже. Даже если нет никаких ошибок, есть определенные ограничения. Они лежат за пределами интерфейса текущего уровня.</summary></entry><entry><title type="html">Ершов о программистах</title><link href="http://yamakarov.ru/life/2018/09/04/ershov-developers.html" rel="alternate" type="text/html" title="Ершов о программистах" /><published>2018-09-04T15:13:00+03:00</published><updated>2018-09-04T15:13:00+03:00</updated><id>http://yamakarov.ru/life/2018/09/04/ershov-developers</id><content type="html" xml:base="http://yamakarov.ru/life/2018/09/04/ershov-developers.html">&lt;p&gt;Сегодня прочитал статью &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%95%D1%80%D1%88%D0%BE%D0%B2,_%D0%90%D0%BD%D0%B4%D1%80%D0%B5%D0%B9_%D0%9F%D0%B5%D1%82%D1%80%D0%BE%D0%B2%D0%B8%D1%87&quot;&gt;академика Ершова&lt;/a&gt; &lt;a href=&quot;http://ershov.iis.nsk.su/ru/node/791295&quot;&gt;О человеческом и эстетическом факторах в программировании&lt;/a&gt; Статья очень интересная, затрагивающая нетехнические аспекты работы программиста. Обсуждается, то что теперь можно называть soft skills.
Для себя я отметил такие моменты:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Главное в работе программиста не сама работа, не деньги, которые за нее платят, а цель с которой работа делается&lt;/li&gt;
  &lt;li&gt;Программирование радикально отличается от других работ требованием к точности выполнения задачи, невозможно даже показать что что-то сделано, если в программе присутствует ошибка, хотя этот эффект нивелируется в больших программах и верен только для небольших подпрограмм&lt;/li&gt;
  &lt;li&gt;Англицизмы присутствовали в разработке программного обеспечения издавна, например Ершов употребляет софтвере&lt;/li&gt;
  &lt;li&gt;Молодые и раньше и теперь имеют сильное преимущество перед опытными программистами в пластичности своего ума и способности быстрее осваивать новые технологии&lt;/li&gt;
  &lt;li&gt;Ершов говорит о балансе между руководителями и исполнителями и трудности реализации конвейера в программном комплексе, о том что среди программистов очень трудно добиться взаимозаменяемости и освещает интересные вопросы командной работы, в частности сравнивает передачу проекта и с отведением детей в интернат, очень сильное утверждение и очень сильно затрагивает струны моей души&lt;/li&gt;
  &lt;li&gt;Отмечена проблема отставания опытных программистов от темпов развития вычислительной техники&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Некоторые вещи в статье устарели, некоторые проблемы решены. 
Но на мой взгляд статья актуальна и по прошествии 40 лет после публикации.&lt;/p&gt;

&lt;p&gt;Очень рекомендую ее к прочтению, учитывая как часто она &lt;a href=&quot;https://twitter.com/FelixTheBest/status/1036522849366880256&quot;&gt;цитируется&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Сегодня прочитал статью академика Ершова О человеческом и эстетическом факторах в программировании Статья очень интересная, затрагивающая нетехнические аспекты работы программиста. Обсуждается, то что теперь можно называть soft skills. Для себя я отметил такие моменты: Главное в работе программиста не сама работа, не деньги, которые за нее платят, а цель с которой работа делается Программирование радикально отличается от других работ требованием к точности выполнения задачи, невозможно даже показать что что-то сделано, если в программе присутствует ошибка, хотя этот эффект нивелируется в больших программах и верен только для небольших подпрограмм Англицизмы присутствовали в разработке программного обеспечения издавна, например Ершов употребляет софтвере Молодые и раньше и теперь имеют сильное преимущество перед опытными программистами в пластичности своего ума и способности быстрее осваивать новые технологии Ершов говорит о балансе между руководителями и исполнителями и трудности реализации конвейера в программном комплексе, о том что среди программистов очень трудно добиться взаимозаменяемости и освещает интересные вопросы командной работы, в частности сравнивает передачу проекта и с отведением детей в интернат, очень сильное утверждение и очень сильно затрагивает струны моей души Отмечена проблема отставания опытных программистов от темпов развития вычислительной техники</summary></entry><entry><title type="html">Поддержка многопоточности в современных программных комплексах</title><link href="http://yamakarov.ru/multi-threading/2018/09/03/multithreading-support.html" rel="alternate" type="text/html" title="Поддержка многопоточности в современных программных комплексах" /><published>2018-09-03T12:08:00+03:00</published><updated>2018-09-03T12:08:00+03:00</updated><id>http://yamakarov.ru/multi-threading/2018/09/03/multithreading-support</id><content type="html" xml:base="http://yamakarov.ru/multi-threading/2018/09/03/multithreading-support.html">&lt;p&gt;Тактовая частота современных процессоров перестала расти из-за физических ограничений.
И теперь для того, чтобы нарастить мощность программного комплекса требуется использование нескольких процессоров одновременно.
В принципе этот способ совершенно не нов и история объединения нескольких процессоров в единый комплекс длинная.
Я не слышал про использование многопроцессорных систем в 50-х годах прошлого века, но уже в 60-х вопрос стоял в полный рост.&lt;/p&gt;

&lt;p&gt;Значимое изменение начала 2000-х заключается в том, что многопроцессорные системы стали доступны широким массам.
Не только сервера и настольные компьютеры стали иметь множество процессоров, но уже процессарами напичканы телефоны и стандартным являются четырех и более процессорные системы.&lt;/p&gt;

&lt;p&gt;Внедрение многопроцессорных систем поднимает ряд проблем.
Основной, как мне кажется, является проблема разработки программного обеспечения для многопоточного программирования.
Большинству людей трудно анализировать многопоточные программы.
Проблема также усугубляется тем, что для поддержка многопоточности требует реализации на всех уровнях программного комплекса:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Железо, просто требуется несколько процессоров для выполнения задач, а это требует их синхронизации&lt;/li&gt;
  &lt;li&gt;Операционные системы, они служат для управления доступом к физическим устройствам и синхронизируют потоки разных программ, и предоставляют специфические средства доступа&lt;/li&gt;
  &lt;li&gt;Прикладное программное обеспечение, большинство задач не поддается автоматическому распаралеливанию, для эффективной работы требуется использование специализированных алгоритмов&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если рассмотреть пример Java, то без понимания реализации многопоточности на всех трех уровнях, совершенно не понятна модель памяти.
Зачем сделаны те или иные допущения, и зачем настолько все усложнено.
Дополнительные интересные моменты привносят оптимизирующие компиляторы, которые не всегда учитывают работу процессоров и в многопоточном выполнении приводят к проблемам, которых нет в последовательном выполнении.&lt;/p&gt;

&lt;p&gt;С ростом количества процессоров на единицу среднего устройства будет расти и количество связанных с синхронизацией проблем.
И большим полем для оптимизации, которую можно проводить исключительно вручную будет распараллеливание программ.&lt;/p&gt;</content><author><name></name></author><summary type="html">Тактовая частота современных процессоров перестала расти из-за физических ограничений. И теперь для того, чтобы нарастить мощность программного комплекса требуется использование нескольких процессоров одновременно. В принципе этот способ совершенно не нов и история объединения нескольких процессоров в единый комплекс длинная. Я не слышал про использование многопроцессорных систем в 50-х годах прошлого века, но уже в 60-х вопрос стоял в полный рост.</summary></entry><entry><title type="html">Острые инструменты</title><link href="http://yamakarov.ru/code/2018/08/23/sharp-tools.html" rel="alternate" type="text/html" title="Острые инструменты" /><published>2018-08-23T12:09:00+03:00</published><updated>2018-08-23T12:09:00+03:00</updated><id>http://yamakarov.ru/code/2018/08/23/sharp-tools</id><content type="html" xml:base="http://yamakarov.ru/code/2018/08/23/sharp-tools.html">&lt;p&gt;Twitter оказался интересным источником новостей о разработке ПО.
Сегодня в нем я нашел интересную статью про языки программирования.
И хотя обычно проскакивают ссылки на новые статьи и сообщения в этот раз новость совсем не новая, 2009 года.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://vanderburg.org/blog/2009/07/13/sharp_and_blunt.html&quot;&gt;Sharp vs. Blunt Instruments&lt;/a&gt; содержит мнение автора о мощных и ограничивающих языках программирования.&lt;/p&gt;

&lt;p&gt;Автор сравнивает Ruby и Java.
Он приходит к выводу, что плохие программисты могут очень сильно извратить ограниченный язык и запустить очень кривую архитектуру.
И на выходе получается, что одинаковые средние программисты на Ruby пишут сносные решения, а на Java отвратительные. 
И пример автора показывает, что бессмысленно ограничивать язык.&lt;/p&gt;

&lt;p&gt;В какой-то мере я согласен с автором.
Я не знаю Ruby, поэтому могу только немного сравнить Clojure и Java.
В целом несмотря на количество разнообразных средств в Clojure для запутывания кода, одни только макросы чего стоят, программы на Clojure у меня получались проще для понимания чем на Java.
Бонусом в Java идет очень серьезная поддержка со стороны IDE и благодаря строгой типизации устранение некоторых багов.
При этом типизацию надо использовать аккуратно и ну путать с наследованием. 
Наследование часто очень сильно запутывает и усложняет код. Функции второго порядка, не идут ни в какое сравнение по сложности с плохо структурированной иерархией классов.&lt;/p&gt;

&lt;p&gt;И в целом я заметил интересную вещь, что язык всегда, но и архитектура приложения влияет на то, что может быть помыслено.
Не помысленное никогда не будет реализовано.&lt;/p&gt;</content><author><name></name></author><summary type="html">Twitter оказался интересным источником новостей о разработке ПО. Сегодня в нем я нашел интересную статью про языки программирования. И хотя обычно проскакивают ссылки на новые статьи и сообщения в этот раз новость совсем не новая, 2009 года.</summary></entry><entry><title type="html">Когда код меняет тебя</title><link href="http://yamakarov.ru/code/2018/08/22/refactoring.html" rel="alternate" type="text/html" title="Когда код меняет тебя" /><published>2018-08-22T15:20:00+03:00</published><updated>2018-08-22T15:20:00+03:00</updated><id>http://yamakarov.ru/code/2018/08/22/refactoring</id><content type="html" xml:base="http://yamakarov.ru/code/2018/08/22/refactoring.html">&lt;p&gt;Заметил такую слабость за собой:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Во время ревью кода я понимаю, что код написан не идеально у этой задачи есть другое лучшее решение&lt;/li&gt;
  &lt;li&gt;Сажусь разбираться с чужим решением, чтобы понять где нужно подправить чтобы получилось мое решение&lt;/li&gt;
  &lt;li&gt;По ходу разбирательства понимаю, что можно подправить и пофиксить баг не воплощая свое лучшее решение&lt;/li&gt;
  &lt;li&gt;Исправляю чужое решение, баг фиксится, но технический долг растет&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;После такой итерации свое решение внедрить становится сложнее, и этот ком растет и растет, пока не начинает влиять на скорость добаления новой функциональности.
Этого никто не замечает, потому что существующее решение не только накладывает ограничения на то, что можно сделать, но она также не дает и помыслить о том что можно сделать.&lt;/p&gt;

&lt;p&gt;Стоит ли всегда внедрять прорывные, порой рискованные решения. Наверное, нет. Стоит ли всегда фиксить плохое решение, ну тоже наверное нет.
Люди выступающие за фиксы, оправдывают это бизнес составляющей, но при этом если бизнес от этого не выигрывает в постоянной конкурентной гонке, что становится очевидно не сразу, то это оправдание не работает.&lt;/p&gt;</content><author><name></name></author><summary type="html">Заметил такую слабость за собой: Во время ревью кода я понимаю, что код написан не идеально у этой задачи есть другое лучшее решение Сажусь разбираться с чужим решением, чтобы понять где нужно подправить чтобы получилось мое решение По ходу разбирательства понимаю, что можно подправить и пофиксить баг не воплощая свое лучшее решение Исправляю чужое решение, баг фиксится, но технический долг растет</summary></entry><entry><title type="html">Даты в Java</title><link href="http://yamakarov.ru/java/2018/08/21/date.html" rel="alternate" type="text/html" title="Даты в Java" /><published>2018-08-21T18:50:00+03:00</published><updated>2018-08-21T18:50:00+03:00</updated><id>http://yamakarov.ru/java/2018/08/21/date</id><content type="html" xml:base="http://yamakarov.ru/java/2018/08/21/date.html">&lt;p&gt;Оказывается два &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Date&lt;/code&gt; могут быть:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;before&lt;/li&gt;
  &lt;li&gt;after&lt;/li&gt;
  &lt;li&gt;equals&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Если подумать то логично, но я сегодня наступил на грабли.&lt;/p&gt;</content><author><name></name></author><summary type="html">Оказывается два java.util.Date могут быть: before after equals</summary></entry><entry><title type="html">Послойная архитектура</title><link href="http://yamakarov.ru/architecture/2018/08/20/layer-architecture.html" rel="alternate" type="text/html" title="Послойная архитектура" /><published>2018-08-20T16:22:00+03:00</published><updated>2018-08-20T16:22:00+03:00</updated><id>http://yamakarov.ru/architecture/2018/08/20/layer-architecture</id><content type="html" xml:base="http://yamakarov.ru/architecture/2018/08/20/layer-architecture.html">&lt;p&gt;Современные web-приложения пишутся в архитектуре клиент-сервер.
В моем случае, в качестве клиента выступает браузер, а в качестве сервера Java приложение работающее на Tomcat с использованием Spring.
Клиентская часть довольно запутана, но можно сказать что она представляет Angular приложение в архитектуре MVC.
Серверная часть проще, это послойная архитектура.
Я обычно выделяю такие слои:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Контроллеры - принимают http запросы, парсят параметры и преобразуют результат в текстовое представление, json или html&lt;/li&gt;
  &lt;li&gt;Сервисы - контроллеры не должны выполнять никакой логики, так как их не очень удобно тестировать, хотя Spring представляет средства и для этого;
сервисы выполняют всю работу и содержат бизнес логику программы&lt;/li&gt;
  &lt;li&gt;Репозитории - в репозиториях строится отображение объектов на таблицы базы данных, объекты разбираются для сохранения и собираются для обработки в сервисах&lt;/li&gt;
  &lt;li&gt;DAO - непосредственно работают с базой данных, в них инкапсулирована логика хранения данных в таблицах, работа с соединениями и другой рутиной доступа к данным&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В целом послойная архитектура упрощает работу.&lt;/p&gt;</content><author><name></name></author><summary type="html">Современные web-приложения пишутся в архитектуре клиент-сервер. В моем случае, в качестве клиента выступает браузер, а в качестве сервера Java приложение работающее на Tomcat с использованием Spring. Клиентская часть довольно запутана, но можно сказать что она представляет Angular приложение в архитектуре MVC. Серверная часть проще, это послойная архитектура. Я обычно выделяю такие слои: Контроллеры - принимают http запросы, парсят параметры и преобразуют результат в текстовое представление, json или html Сервисы - контроллеры не должны выполнять никакой логики, так как их не очень удобно тестировать, хотя Spring представляет средства и для этого; сервисы выполняют всю работу и содержат бизнес логику программы Репозитории - в репозиториях строится отображение объектов на таблицы базы данных, объекты разбираются для сохранения и собираются для обработки в сервисах DAO - непосредственно работают с базой данных, в них инкапсулирована логика хранения данных в таблицах, работа с соединениями и другой рутиной доступа к данным</summary></entry><entry><title type="html">Пример использования PhantomReference</title><link href="http://yamakarov.ru/java/phantom/2018/08/17/phantom.html" rel="alternate" type="text/html" title="Пример использования PhantomReference" /><published>2018-08-17T12:41:00+03:00</published><updated>2018-08-17T12:41:00+03:00</updated><id>http://yamakarov.ru/java/phantom/2018/08/17/phantom</id><content type="html" xml:base="http://yamakarov.ru/java/phantom/2018/08/17/phantom.html">&lt;p&gt;В ленте Twitter прочитал &lt;a href=&quot;https://twitter.com/dbg_nsk/status/1030313002208292864&quot;&gt;задачку&lt;/a&gt; про &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/PhantomReference.html&quot;&gt;PhantomReference&lt;/a&gt;
Я решил посмотреть, как используются фантомные ссылки в Одноклассниках.
В приведенном коде я использую идею из кодовой базы проекта, но с добавлением собственных комментариев и багов, в силу скудоумия:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ru&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;yamakarov&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;examples&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.lang.ref.PhantomReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.lang.ref.ReferenceQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.concurrent.ConcurrentHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Phantom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;gc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Ресурс, который мы хотим почистить, когда объект станет доступен только по фантомной ссылке&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;resource&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Объект использующий ресурс&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Garbage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;garbage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Garbage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;garbage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

            &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Cleaned &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Класс освобождающий ресурсы после того, как использующий их объект стал недоступен&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cleaner&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;PhantomReference&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Очередь в которую попадают объекты требующие очистки&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReferenceQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReferenceQueue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Храним ссылки, чтобы они не были собраны сборкой мусора&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcurrentHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allCleaners&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConcurrentHashMap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;Cleaner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;allCleaners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;interrupt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Делаем поток демоном, так как он должен остановиться когда закончилось приложение&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setDaemon&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Cleaner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;referent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;referent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;allCleaners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;clean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Garbage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Garbage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Garbage{&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;resource='&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'\''&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;sc&quot;&gt;'}'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">В ленте Twitter прочитал задачку про PhantomReference Я решил посмотреть, как используются фантомные ссылки в Одноклассниках. В приведенном коде я использую идею из кодовой базы проекта, но с добавлением собственных комментариев и багов, в силу скудоумия:</summary></entry></feed>