<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://yamakarov.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="http://yamakarov.ru/" rel="alternate" type="text/html" /><updated>2018-06-21T09:51:07+03:00</updated><id>http://yamakarov.ru/</id><title type="html">Записки Java программиста</title><subtitle>Блог о разработке web админок, CRM-ок и прочего. 
</subtitle><entry><title type="html">Язык программирования Forth</title><link href="http://yamakarov.ru/forth/2018/06/21/fort-materials.html" rel="alternate" type="text/html" title="Язык программирования Forth" /><published>2018-06-21T09:12:00+03:00</published><updated>2018-06-21T09:12:00+03:00</updated><id>http://yamakarov.ru/forth/2018/06/21/fort-materials</id><content type="html" xml:base="http://yamakarov.ru/forth/2018/06/21/fort-materials.html">&lt;p&gt;Есть такой замечательный язык &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)&quot;&gt;Forth&lt;/a&gt;.
Написал его настоящий мужик &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D1%80,_%D0%A7%D0%B0%D1%80%D0%BB%D1%8C%D0%B7_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82)&quot;&gt;Чарльз Мур&lt;/a&gt;, который родился в эпоху
когда мужчины сами писали драйверы устройств(&lt;a href=&quot;https://ru.wikiquote.org/wiki/%D0%9B%D0%B8%D0%BD%D1%83%D1%81_%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81&quot;&gt;Торвальдс&lt;/a&gt;).
Forth славится своей возможностью очень быстро переходить от машинных команд к высокоуровневым концепциям.
И у меня есть задумка написать свой компилятор Forth c &lt;a href=&quot;http://lurkmore.to/%D0%91%D0%BB%D1%8D%D0%BA%D0%B4%D0%B6%D0%B5%D0%BA_%D0%B8_%D1%88%D0%BB%D1%8E%D1%85%D0%B8&quot;&gt;карамболем и профурсетками&lt;/a&gt;, чтобы лучше разобраться в устройстве компьютера.
Такое проделывали многие, например &lt;a href=&quot;https://rwmj.wordpress.com/2010/08/07/jonesforth-git-repository/&quot;&gt;Richard Jones&lt;/a&gt;.
Есть &lt;a href=&quot;https://github.com/nornagon/jonesforth&quot;&gt;репозиторий на Github&lt;/a&gt;, а сам тьюториал в файле &lt;a href=&quot;https://github.com/nornagon/jonesforth/blob/master/jonesforth.S&quot;&gt;jonesforth.S&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Есть такой замечательный язык Forth. Написал его настоящий мужик Чарльз Мур, который родился в эпоху когда мужчины сами писали драйверы устройств(Торвальдс). Forth славится своей возможностью очень быстро переходить от машинных команд к высокоуровневым концепциям. И у меня есть задумка написать свой компилятор Forth c карамболем и профурсетками, чтобы лучше разобраться в устройстве компьютера. Такое проделывали многие, например Richard Jones. Есть репозиторий на Github, а сам тьюториал в файле jonesforth.S</summary></entry><entry><title type="html">Использование off-heap памяти в Java</title><link href="http://yamakarov.ru/java/2018/06/20/off-heap-java.html" rel="alternate" type="text/html" title="Использование off-heap памяти в Java" /><published>2018-06-20T14:18:00+03:00</published><updated>2018-06-20T14:18:00+03:00</updated><id>http://yamakarov.ru/java/2018/06/20/off-heap-java</id><content type="html" xml:base="http://yamakarov.ru/java/2018/06/20/off-heap-java.html">&lt;p&gt;&lt;a href=&quot;https://mechanical-sympathy.blogspot.com/2012/10/compact-off-heap-structurestuples-in.html&quot;&gt;Compact Off-Heap Structures/Tuples In Java&lt;/a&gt; - интересный пост, показывающий как легко и непринужденно можно было работать с памятью вне кучи с использованием &lt;a href=&quot;https://anton-arhipov.livejournal.com/264843.html&quot;&gt;Unsafe&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Compact Off-Heap Structures/Tuples In Java - интересный пост, показывающий как легко и непринужденно можно было работать с памятью вне кучи с использованием Unsafe</summary></entry><entry><title type="html">Процессорный кэш</title><link href="http://yamakarov.ru/processor/cache/2018/06/19/processor-cache.html" rel="alternate" type="text/html" title="Процессорный кэш" /><published>2018-06-19T14:45:00+03:00</published><updated>2018-06-19T14:45:00+03:00</updated><id>http://yamakarov.ru/processor/cache/2018/06/19/processor-cache</id><content type="html" xml:base="http://yamakarov.ru/processor/cache/2018/06/19/processor-cache.html">&lt;p&gt;Современные процессоры очень быстро работают.
Они умеют:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;одновременно выполнять несколько операций, это называется конвейерезацией.&lt;/li&gt;
  &lt;li&gt;автоматически распаралеливать выполнение независимых операций, это называется суперскалярностью.&lt;/li&gt;
  &lt;li&gt;переставлять операции местами, чтобы увеличить пропускную способность конвейера&lt;/li&gt;
  &lt;li&gt;делать спекулятивное выполнение и потом отбрасывать результат&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Это очень круто и очень мощно.
Но есть проблема. 
Очень часто нужно считать данные из памяти, а потом записать результат в память. 
Это не распаралеливается.
А память медленная отчасти из-за растояния до процессора, от того что конденсаторы не могут мгновенно разрядиться и т.д.
В зависимости от устройства доступ к памяти занимает от 20 до 100 тактов процессора.
Очень долго!&lt;/p&gt;

&lt;p&gt;Стандартное решение такой задачи это кэширование. 
И мы кэшируем, где можем, сколько можем и когда можем.
Со следующими ограничениями на всех уровнях. 
Чем больше кэш, тем дольше к нему доступ. Это следствие физических ограничений, все быстрое потребляет много энергии, и плотность размещения элементов ограничена.&lt;/p&gt;</content><author><name></name></author><summary type="html">Современные процессоры очень быстро работают. Они умеют: одновременно выполнять несколько операций, это называется конвейерезацией. автоматически распаралеливать выполнение независимых операций, это называется суперскалярностью. переставлять операции местами, чтобы увеличить пропускную способность конвейера делать спекулятивное выполнение и потом отбрасывать результат</summary></entry><entry><title type="html">Теоретически некоторые программисты достигают этого минимума</title><link href="http://yamakarov.ru/cs/2018/06/18/theoretical-min.html" rel="alternate" type="text/html" title="Теоретически некоторые программисты достигают этого минимума" /><published>2018-06-18T15:14:00+03:00</published><updated>2018-06-18T15:14:00+03:00</updated><id>http://yamakarov.ru/cs/2018/06/18/theoretical-min</id><content type="html" xml:base="http://yamakarov.ru/cs/2018/06/18/theoretical-min.html">&lt;p&gt;&lt;a href=&quot;https://sharpc.livejournal.com/67583.html&quot;&gt;Теоретический минимум для программиста&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Теоретический минимум для программиста</summary></entry><entry><title type="html">RISC и x86</title><link href="http://yamakarov.ru/x86/risc/2018/06/15/x86-risc.html" rel="alternate" type="text/html" title="RISC и x86" /><published>2018-06-15T15:01:00+03:00</published><updated>2018-06-15T15:01:00+03:00</updated><id>http://yamakarov.ru/x86/risc/2018/06/15/x86-risc</id><content type="html" xml:base="http://yamakarov.ru/x86/risc/2018/06/15/x86-risc.html">&lt;p&gt;Оказывается современные x86 процессоры работают как конвейерные суперскаляры.
Для этого они декодируют инструкции ассемблера в микрокоманды примерно по такой схеме:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://yamakarov.ru/img/riscyx862.svg&quot; alt=&quot;CISC инструкции ассемблера в RISC микрокоманды&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Оказывается современные x86 процессоры работают как конвейерные суперскаляры. Для этого они декодируют инструкции ассемблера в микрокоманды примерно по такой схеме:</summary></entry><entry><title type="html">Интересное введение в архитектуру современных процессоров</title><link href="http://yamakarov.ru/hardware/2018/06/14/modern-processors.html" rel="alternate" type="text/html" title="Интересное введение в архитектуру современных процессоров" /><published>2018-06-14T15:12:00+03:00</published><updated>2018-06-14T15:12:00+03:00</updated><id>http://yamakarov.ru/hardware/2018/06/14/modern-processors</id><content type="html" xml:base="http://yamakarov.ru/hardware/2018/06/14/modern-processors.html">&lt;p&gt;&lt;a href=&quot;http://www.lighterra.com/papers/modernmicroprocessors/&quot;&gt;Modern Microprocessors. A 90-Minute Guide!&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Modern Microprocessors. A 90-Minute Guide!</summary></entry><entry><title type="html">Регистры в архитектуре x86-64</title><link href="http://yamakarov.ru/x86_64/2018/06/14/registers.html" rel="alternate" type="text/html" title="Регистры в архитектуре x86-64" /><published>2018-06-14T09:56:00+03:00</published><updated>2018-06-14T09:56:00+03:00</updated><id>http://yamakarov.ru/x86_64/2018/06/14/registers</id><content type="html" xml:base="http://yamakarov.ru/x86_64/2018/06/14/registers.html">&lt;p&gt;В архитектуре &lt;a href=&quot;https://ru.wikipedia.org/wiki/X86-64&quot;&gt;x86-64&lt;/a&gt; существуют следующие &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0&quot;&gt;регистры&lt;/a&gt; общего назначения:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RAX - аккумулятор, потому что в него часть инструкций складывает результат выполнения&lt;/li&gt;
  &lt;li&gt;RBX - инструкции используют как адрес начала данных&lt;/li&gt;
  &lt;li&gt;RCX - используется в качестве счетчика цикла и автоматически уменьшается рядом команд&lt;/li&gt;
  &lt;li&gt;RDX - регистр данных, по-видимому можно использовать для чего угодно и специального назначения не имеет&lt;/li&gt;
  &lt;li&gt;RSI - источник, адрес в памяти для получения данных&lt;/li&gt;
  &lt;li&gt;RDI - получатель, адрес в памяти куда записываются данные&lt;/li&gt;
  &lt;li&gt;RBP - регистр базы кадра стека для организации вызова функций&lt;/li&gt;
  &lt;li&gt;RSP - регистр указателя стека для определения места в памяти где начинается стек&lt;/li&gt;
  &lt;li&gt;R8-R15 - неименованные и могут использоваться для различных операций&lt;/li&gt;
  &lt;li&gt;RFLAGS - регистр флагов с разными полезными битами&lt;/li&gt;
  &lt;li&gt;RIP - содержит адрес текущий выполняемой команды, и данные сюда заносить не надо, это делает сам процессор при выполнении операций перехода&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">В архитектуре x86-64 существуют следующие регистры общего назначения:</summary></entry><entry><title type="html">Отимизация ассемблерного кода</title><link href="http://yamakarov.ru/assembler/2018/06/13/assembler-optimisations.html" rel="alternate" type="text/html" title="Отимизация ассемблерного кода" /><published>2018-06-13T12:46:00+03:00</published><updated>2018-06-13T12:46:00+03:00</updated><id>http://yamakarov.ru/assembler/2018/06/13/assembler-optimisations</id><content type="html" xml:base="http://yamakarov.ru/assembler/2018/06/13/assembler-optimisations.html">&lt;p&gt;Хочу поделиться ресурсами, которые мне понравились в процессе изучения ассемблера:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.stolyarov.info/books/asm_unix&quot;&gt;Программирование на языке ассемблера NASM для ОС Unix&lt;/a&gt; - доступным языком описаны основы программирования на ассемблере под Linux. 
Это пособие. Автор также выпустил серию книг &lt;a href=&quot;http://www.stolyarov.info/books/programming_intro&quot;&gt;Программирование: Введение в профессию&lt;/a&gt;, в которую входит материал из пособия.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.agner.org/optimize&quot;&gt;Сайт Agner Fog&lt;/a&gt; здесь большое колчичество материалов по оптимизации ассемблерного кода и в отличии от &lt;a href=&quot;https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4&quot;&gt;Intel руководства&lt;/a&gt; подробно разбираются прикладные вещи, то что трудно понять из сухого описания процессорных команд&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Хочу поделиться ресурсами, которые мне понравились в процессе изучения ассемблера: Программирование на языке ассемблера NASM для ОС Unix - доступным языком описаны основы программирования на ассемблере под Linux. Это пособие. Автор также выпустил серию книг Программирование: Введение в профессию, в которую входит материал из пособия. Сайт Agner Fog здесь большое колчичество материалов по оптимизации ассемблерного кода и в отличии от Intel руководства подробно разбираются прикладные вещи, то что трудно понять из сухого описания процессорных команд</summary></entry><entry><title type="html">Разбор Hello nasm</title><link href="http://yamakarov.ru/assembler/nasm/2018/06/09/hello-nasm-demystified.html" rel="alternate" type="text/html" title="Разбор Hello nasm" /><published>2018-06-09T10:29:00+03:00</published><updated>2018-06-09T10:29:00+03:00</updated><id>http://yamakarov.ru/assembler/nasm/2018/06/09/hello-nasm-demystified</id><content type="html" xml:base="http://yamakarov.ru/assembler/nasm/2018/06/09/hello-nasm-demystified.html">&lt;p&gt;В посте &lt;a href=&quot;/assembler/nasm/2018/06/08/nasm.html&quot;&gt;“Hello nasm assembler”&lt;/a&gt; я привел пример программы на ассемблере &lt;a href=&quot;https://www.nasm.us&quot;&gt;nasm&lt;/a&gt; для Mac OS, но совершенно не рассказал как она работает.
Повторю её ещё раз код программы:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;table style=&quot;border-spacing: 0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter gl&quot; style=&quot;text-align: right&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c&quot;&gt;; /usr/local/bin/nasm -f macho64 64.asm &amp;amp;&amp;amp; ld -macosx_version_min 10.7.0 -lSystem -o 64 64.o &amp;amp;&amp;amp; ./64&lt;/span&gt;
  
&lt;span class=&quot;kr&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
   
&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000004&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; write&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; stdout&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;syscall&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000001&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; exit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;syscall&lt;/span&gt;
  
  
&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;db&lt;/span&gt;      &lt;span class=&quot;s&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;equ&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Комментарии к коду программы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;В &lt;a href=&quot;https://www.nasm.us/doc/nasmdoc3.html&quot;&gt;языке nasm&lt;/a&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt; обозначает комментарии. Строчка 1.&lt;/li&gt;
  &lt;li&gt;В строчке 3 &lt;code class=&quot;highlighter-rouge&quot;&gt;global start&lt;/code&gt; для &lt;a href=&quot;https://stackoverflow.com/a/17899048/6677530&quot;&gt;линкера указывается&lt;/a&gt; с какого места начинать выполнение программы&lt;/li&gt;
  &lt;li&gt;Директива &lt;code class=&quot;highlighter-rouge&quot;&gt;section&lt;/code&gt; задает секции для &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D0%B9_%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D1%8C&quot;&gt;объектных файлов&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;.text (строка 5) - для кода, стандартный в Linux
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;start:&lt;/code&gt; в 7 строчке метка, она отмечает место в коде на которое можно переходить&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; и &lt;code class=&quot;highlighter-rouge&quot;&gt;syscall&lt;/code&gt; &lt;a href=&quot;https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf&quot;&gt;x86 операторы&lt;/a&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mov&lt;/code&gt; помещает данные в регистры&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;syscall&lt;/code&gt; осуществляет системный вызов и передает управление ядру операционной системы&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rax, rdi, rsi, rdx&lt;/code&gt; регистры общего назначения в которые кладутся данные, имеют стандартные способы использования
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rax&lt;/code&gt; - аккумулятор&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rdi&lt;/code&gt; - указатель на получатель для строк&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; - указатель на источник для строк&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rdx&lt;/code&gt; - указатель Ввода/Вывода&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2000004, 0x2000001&lt;/code&gt; константы для идентификации системных вызовов на Windows и Linux будут другие&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;.data (строка 19) - для констант, тоже стандартный
        &lt;ul&gt;
          &lt;li&gt;с помощью меток строки 21, 22 можно объявлять переменные, причем &lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt; значит что переменная локальная и относится к ближайшей сверху метке. Точке может быть несколько.&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;db &quot;Hello, world!&quot;, 10&lt;/code&gt; инициализирует данные в выходном файле, объектном &lt;a href=&quot;https://www.nasm.us/doc/nasmdoc3.html#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;equ    $ - msg&lt;/code&gt; присваивает метке константное значение. В данном случае из отступа начала данной метки вычитается отступ msg и мы получаем длину msg в байтах &lt;a href=&quot;https://www.nasm.us/doc/nasmdoc3.html#section-3.2.4&quot;&gt;section 3.2.4&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">В посте “Hello nasm assembler” я привел пример программы на ассемблере nasm для Mac OS, но совершенно не рассказал как она работает. Повторю её ещё раз код программы:</summary></entry><entry><title type="html">Hello nasm assembler</title><link href="http://yamakarov.ru/assembler/nasm/2018/06/08/nasm.html" rel="alternate" type="text/html" title="Hello nasm assembler" /><published>2018-06-08T12:33:00+03:00</published><updated>2018-06-08T12:33:00+03:00</updated><id>http://yamakarov.ru/assembler/nasm/2018/06/08/nasm</id><content type="html" xml:base="http://yamakarov.ru/assembler/nasm/2018/06/08/nasm.html">&lt;p&gt;В продолжение темы про &lt;a href=&quot;/memory/2018/05/23/memory-hierarchy.html&quot;&gt;иерархию памяти&lt;/a&gt; я решил написать пост про &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0&quot;&gt;регистры процессора&lt;/a&gt;. 
Однако, это оказалось очень большой темой, о которой я не могу написать кратенько. Видимо, потому что плохо в этом разбираюсь.
Программируя на Java мне никогда не приходилось оперировать регистрами.
Это очень низкоуровневые вещи.
Однако, чтобы разбираться с проблемами в производительности о регистрах надо знать.
Для того, чтобы потрогать регистры я установил &lt;a href=&quot;https://www.nasm.us/index.php&quot;&gt;Nasm&lt;/a&gt;.
Он первый попался под руку и поддерживал Windows синтаксис, который мне показался понятнее Linux варианта.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install nasm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;В первой же ссылке в Google на &lt;em&gt;&lt;a href=&quot;https://gist.github.com/FiloSottile/7125822&quot;&gt;mac os assembler hello world&lt;/a&gt;&lt;/em&gt; оказалось:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-nasm&quot; data-lang=&quot;nasm&quot;&gt;&lt;span class=&quot;c&quot;&gt;; /usr/local/bin/nasm -f macho64 64.asm &amp;amp;&amp;amp; ld -macosx_version_min 10.7.0 -lSystem -o 64 64.o &amp;amp;&amp;amp; ./64&lt;/span&gt;
  
&lt;span class=&quot;kr&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;
   
&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;text&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000004&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; write&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; stdout&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;syscall&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000001&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;; exit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;syscall&lt;/span&gt;
  
  
&lt;span class=&quot;kr&quot;&gt;section&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
  
&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;db&lt;/span&gt;      &lt;span class=&quot;s&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;equ&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Если этот код сохранить в файле &lt;strong&gt;64.asm&lt;/strong&gt; и выполнить первую строчку из файла, то она дейсвительно выведет:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello, world!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Viola!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Почему так происходит я постараюсь рассказать в следующих постах.&lt;/p&gt;</content><author><name></name></author><summary type="html">В продолжение темы про иерархию памяти я решил написать пост про регистры процессора. Однако, это оказалось очень большой темой, о которой я не могу написать кратенько. Видимо, потому что плохо в этом разбираюсь. Программируя на Java мне никогда не приходилось оперировать регистрами. Это очень низкоуровневые вещи. Однако, чтобы разбираться с проблемами в производительности о регистрах надо знать. Для того, чтобы потрогать регистры я установил Nasm. Он первый попался под руку и поддерживал Windows синтаксис, который мне показался понятнее Linux варианта.</summary></entry></feed>