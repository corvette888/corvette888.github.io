<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://yamakarov.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="http://yamakarov.ru/" rel="alternate" type="text/html" /><updated>2018-09-18T18:41:55+03:00</updated><id>http://yamakarov.ru/</id><title type="html">Записки Java программиста</title><subtitle>Блог о разработке web админок, CRM-ок и прочего. 
</subtitle><entry><title type="html">Angular западня</title><link href="http://yamakarov.ru/angular/2018/09/18/angular-pitfalls.html" rel="alternate" type="text/html" title="Angular западня" /><published>2018-09-18T18:13:00+03:00</published><updated>2018-09-18T18:13:00+03:00</updated><id>http://yamakarov.ru/angular/2018/09/18/angular-pitfalls</id><content type="html" xml:base="http://yamakarov.ru/angular/2018/09/18/angular-pitfalls.html">&lt;p&gt;Для внутренней фронтенд разработки мы используем &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;.
Это отличный фреймворк, который существенно ускоряет разработку.
В связке с &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;Typescript&lt;/a&gt; он становится еще мощнее.&lt;/p&gt;

&lt;p&gt;Преимуществом Angular является то, что на нем очень удобно делать компоненты и управлять состоянием.
Идея отслеживать изменения модели и автоматически перерисовывать представление оказывается очень мощной.
Ею легко овладеть.
Несмотря на то, что порог вхождения считается довольно высоким из моего получается, что это не так.
У одного и того же разработчика, на jQuery и Angular получаются очень разные по функциональности компоненты.&lt;/p&gt;

&lt;p&gt;Скажем так, что на jQuery они вообще не получаются, на выходе месиво из разных функций, беспорядочно вызываемых.
В то же время на Angular все разбито на компоненты и более менее упорядочено.&lt;/p&gt;

&lt;p&gt;Но кое за что мне хочется поругать Angular.
В нем довольно сложно переиспользовать компоненты.
Из-за того, что фреймворк нещадно смешивает html и код приложения, трудно отделить верстку от бизнес логики.
И мои приложения получаются сборником довольно разувесистых компонент, которые совсем не комбинируются друг с другом, 
а просто являются отдельными страницами приложения.&lt;/p&gt;

&lt;p&gt;В этом плане мне нравится идея, так сказать перенести рендеринг на сервер.
Там можно строить тот же виртуальный дом, что строится на клиенте при изменении модели и отправлять назад в браузер.
Клиентскому коду останется только собирать ввод пользователя, отправлять на сервер и подставлять в реальный dom, dom отрендаренный на сервере.&lt;/p&gt;

&lt;p&gt;Что это даст?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Клиент будет содержать минимальную, хотя и довольно сложную логику&lt;/li&gt;
  &lt;li&gt;Все компоненты будут строиться, а значит и тестироваться на сервере, тут можно возразить, что тестировать можно и клиентский Angular, но иметь два фреймворка для тестирования хуже чем один и потому тестировать на сервере мне видится проще&lt;/li&gt;
  &lt;li&gt;Такой подход удобен для индексации поисковиками, хотя это и не случай внутренней разработки&lt;/li&gt;
  &lt;li&gt;При генерации html серверными функциями можно пользоваться всею мощью любимой IDE&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Для внутренней фронтенд разработки мы используем Angular. Это отличный фреймворк, который существенно ускоряет разработку. В связке с Typescript он становится еще мощнее.</summary></entry><entry><title type="html">Мощь командной строки</title><link href="http://yamakarov.ru/commandline/2018/09/17/command-line-power.html" rel="alternate" type="text/html" title="Мощь командной строки" /><published>2018-09-17T17:38:00+03:00</published><updated>2018-09-17T17:38:00+03:00</updated><id>http://yamakarov.ru/commandline/2018/09/17/command-line-power</id><content type="html" xml:base="http://yamakarov.ru/commandline/2018/09/17/command-line-power.html">&lt;p&gt;Этот блог я веду с помощью системы &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; и размещаю на &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github pages&lt;/a&gt;.
Я делаю это где-то в течение полугода &lt;a href=&quot;/kotlin/2018/04/08/kotlin-coroutines.html&quot;&gt;первый пост&lt;/a&gt; я написал 8 апреля.
На Github Pages размещаются статические странички моего блога, которые генерятся с помощью Jekyll.
Jekyll позволяет писать сообщения в любом текстовом редакторе.
Я использую Vim.
Это оказалось очень удобно, гораздо удобнее чем писать в каком-либо браузерном редакторе или писать в текстовом редакторе, а потом для постинга переносить в браузер.
Для работы я завел несколько командных скриптов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new-post&lt;/code&gt; для создания нового сообщения&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;publish&lt;/code&gt; для публикация своего сообщения&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serve&lt;/code&gt; для локального запуска Jekyll, чтобы можно было посмотреть как выглядит мой пост в браузере&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;И мне очень нравится такой вид работы.
Я написал небольшую Java &lt;a href=&quot;/java/jekyll/2018/04/09/jekyll-boost.html&quot;&gt;программу для генерации постов по шаблону&lt;/a&gt;.
Она маленькая и простая, но позволяет значительно уменьшить время для создания сообщения и преодолеть рубеж от хочу написать пост до пишу пост.
Я думаю, что если бы не написал ее в самом начале, то не смог бы столько времени постить в свой блог.
Когда я ее писал, казалось, что Java не лучший выбор для такого рода задачи, но теперь когда она несколько месяцев работает и не требует изменений, я вполне удовлетворен выбором.
И не замечаю какая она медленная, как никак на страте запускается Java и какая она многословная, потому что она просто работает.&lt;/p&gt;

&lt;p&gt;Раньше для меня было особенно трудно после перерыва начать выполнять какие-то простые действия заново.
Например, запуск разработческого сервера.
И сильно оценил то, что догадался основные операции вынести в скрипты.
Мне достаточно зайти в папочку &lt;code class=&quot;highlighter-rouge&quot;&gt;utils&lt;/code&gt; и я найду все команды для запуска, но также и смогу посмотреть что они делают.
Это такая себе самодокументация.
Говорят, что некоторые используют make для этого и очень успешно.
Возможно мне тоже стоит прикрутить какие-нибудь средства автоматизации, но пока я даже не могу представить чем улучшить мой процесс постинга.
Большую часть времени я трачу на дело, придумывание заголовка и написание статьи.&lt;/p&gt;

&lt;p&gt;Также мне нравится писать сообщения в Vim, это мощный удобный редактор с большими возможностями. 
Например я пользуюсь проверкой орфографии и это хорошо работает.&lt;/p&gt;

&lt;p&gt;Я управляю блогом из командной строки и для меня это самый удобный способ на данный момент.
И в этом я вижу мощь командной строки.&lt;/p&gt;</content><author><name></name></author><summary type="html">Этот блог я веду с помощью системы Jekyll и размещаю на Github pages. Я делаю это где-то в течение полугода первый пост я написал 8 апреля. На Github Pages размещаются статические странички моего блога, которые генерятся с помощью Jekyll. Jekyll позволяет писать сообщения в любом текстовом редакторе. Я использую Vim. Это оказалось очень удобно, гораздо удобнее чем писать в каком-либо браузерном редакторе или писать в текстовом редакторе, а потом для постинга переносить в браузер. Для работы я завел несколько командных скриптов: new-post для создания нового сообщения publish для публикация своего сообщения serve для локального запуска Jekyll, чтобы можно было посмотреть как выглядит мой пост в браузере</summary></entry><entry><title type="html">Интересный пост о базах данных от Марка Келегана</title><link href="http://yamakarov.ru/databases/2018/09/14/mark-about-db.html" rel="alternate" type="text/html" title="Интересный пост о базах данных от Марка Келегана" /><published>2018-09-14T12:06:00+03:00</published><updated>2018-09-14T12:06:00+03:00</updated><id>http://yamakarov.ru/databases/2018/09/14/mark-about-db</id><content type="html" xml:base="http://yamakarov.ru/databases/2018/09/14/mark-about-db.html">&lt;p&gt;Очень интересный &lt;a href=&quot;http://smalldatum.blogspot.com/2018/09/review-of-slimdb-from-vldb-2018.html&quot;&gt;пост о базах данных&lt;/a&gt;.
Марк рекомендует прочитать статью про &lt;a href=&quot;http://www.vldb.org/pvldb/vol10/p2037-ren.pdf&quot;&gt;новый результаты в алгоритмах баз данных&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Дается краткое описание статьи, чтобы заинтересовать читателя в ее прочтении.
Особенно мне понравился тезис о том, что статья не должны быть идеальной, чтобы ее стоило прочитать.
Как я понял, эта статья как раз не идеальная, но ее стоить читать.
Сейчас, когда пишется огромное количество статей, прочитать все невозможно и, чтобы не пропустить важное, надо грамотно выбирать материалы для чтения.&lt;/p&gt;

&lt;p&gt;Также в сообщении Марка мне очень понравилось обилие ссылок на сопутствующие материалы.
Он дает краткие описания к статьям из списка литературы и создает целостную картину мира.
Статьи не появляются из ниоткуда, обычно они являются продолжением чьей либо работы, развитие идей или уточнение результатов.
По этой причине важно понимать что откуда берется и куда следует.&lt;/p&gt;

&lt;p&gt;Читать статьи тяжело. 
Пока я это не понял, я вообще не читал статьи, а ограничивался материалами блогов.
Однако, как я вижу и по тому, что получается у меня, читать блоги очень неэффективное занятие.
Труднее, но при этом полезнее читать статьи.
Их приходится читать по несколько раз, чтобы уложить новые идеи в своей голове.
Это признает Марк, он говорит что статья трудная и надо приложить усилия чтобы разобраться.
Я частенько сталкиваюсь с тем, что даже после нескольких прочтений не понимаю написанного.
Это по-видимому нормально, иногда надо просто идти дальше и с накоплением знаний придет и понимание.&lt;/p&gt;</content><author><name></name></author><summary type="html">Очень интересный пост о базах данных. Марк рекомендует прочитать статью про новый результаты в алгоритмах баз данных.</summary></entry><entry><title type="html">О сложных SQL запросах</title><link href="http://yamakarov.ru/sql/2018/09/13/complex-sql-queries.html" rel="alternate" type="text/html" title="О сложных SQL запросах" /><published>2018-09-13T19:22:00+03:00</published><updated>2018-09-13T19:22:00+03:00</updated><id>http://yamakarov.ru/sql/2018/09/13/complex-sql-queries</id><content type="html" xml:base="http://yamakarov.ru/sql/2018/09/13/complex-sql-queries.html">&lt;p&gt;SQL выразительный язык.
На нем можно писать сложные запросы, делать различного вида джойны и получать интересные результаты при минимальных усилиях.
Однако из-за того, что разработчик не имеет полного контроля над тем как выполняется запрос могут происходить очень странные вещи.
Сервер баз данных строит план запроса для того, чтобы получить данные.
Этот план очень сильно зависит от статистики собранной сервером.
Эту статистику надо держать актуальной, но об этом нередко забывают.
И на выходе мы имеем жутко неоптимальный план.&lt;/p&gt;

&lt;p&gt;В своей практике я столкнулся с тем, что в какой-то момент из-за изменений в статистике запросы стали выполняться на 2 порядка медленней чем это было.
Такое поведение совершенно неприемлимо в сколько-нибудь нагруженных системах с большим количеством пользователей.
Представьте, что в пик времени продаж, запрос на оформление заказа станет выполняться в 100 раз медленнее и вы потеряете 90 процентов заказов.
Эти убытки будут никак не сравнимы с теми деньгами, которые вы сэкономили на разработке благодаря выразительности SQL.
По этой причине в нагруженных системах избегают сложных запросов.
Пусть мы напишем больше кода, пусть потратим на это больше времени, пусть это будет даже работать медленнее, лишь бы это время было предсказуемо.
Мы хотим знать сколько времени займет запрос и хотим гарантий на максимальное время запроса.&lt;/p&gt;

&lt;p&gt;Отсюда идут запреты на использование джойнов и необходимость строить индексы по всем запросам.
А без джойнов вам остаются только простые селекты, а с индексами уже и не нужен особо умный оптимизатор и если он все равно когда-нибудь решит делать полный скан таблицы, вы еще вдобавок к имеющемся ограничениям накидаете хинтов.&lt;/p&gt;

&lt;p&gt;В принципе, такая картина видна не только в SQL. 
Это классическая текущая абстракция.
Разработчику в какой-то момент нужен полный контроль, и очень высоко ценятся разработчики, которые умеют этот контроль получить и использовать.
И мне все хочется найти, но пока никак не получается, реализацию идею из книги Дейта об интеграции языка программирования и языка запросов к базе данных.
И того, что я видел ближе всего к этому подобрался LINQ, на Java я ничего подобного не встречал и в текущих проектах пишу сугубо императивный код, всеми силами избегая декларативщины.&lt;/p&gt;</content><author><name></name></author><summary type="html">SQL выразительный язык. На нем можно писать сложные запросы, делать различного вида джойны и получать интересные результаты при минимальных усилиях. Однако из-за того, что разработчик не имеет полного контроля над тем как выполняется запрос могут происходить очень странные вещи. Сервер баз данных строит план запроса для того, чтобы получить данные. Этот план очень сильно зависит от статистики собранной сервером. Эту статистику надо держать актуальной, но об этом нередко забывают. И на выходе мы имеем жутко неоптимальный план.</summary></entry><entry><title type="html">Хипстерские технологии</title><link href="http://yamakarov.ru/software/2018/09/12/hipster-tech.html" rel="alternate" type="text/html" title="Хипстерские технологии" /><published>2018-09-12T18:12:00+03:00</published><updated>2018-09-12T18:12:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/12/hipster-tech</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/12/hipster-tech.html">&lt;p&gt;Сложно выбрать технологии для нового проекта.
Если смотреть на типичную админку, то надо выбрать:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Базу данных, где вы будете хранить данные&lt;/li&gt;
  &lt;li&gt;Сервер приложений, то как вы будете обрабатывать данные на сервере&lt;/li&gt;
  &lt;li&gt;Браузерные технологии, Angular там или React, или все отрендарите на сервере&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Я хочу отметить два момента.
Нельзя постоянно пользоваться проверенными технологиями. 
Они имеют свойство устаревать и в какой-то момент ты понимаешь, что твоя технология безнадежно устарела, считай стала дорогой в эксплуатации.
Чтобы развивать приложение дальше, трудно найти разработчиков, от этого они дороже.
А трудно найти, потому что производительность на другой технологии выше и там платят больше, и тому подобное.&lt;/p&gt;

&lt;p&gt;Есть и другая крайность, когда в проект берется все самое новое.
Часто это все непроверенное без должной поддержки программное обеспечение, которое может быть в любой момент заброшено авторами.
Я бы брал новое, только когда очевидно, что оно приносит пользу в конкретных условиях проекта.
Можно также брать в рамках эксперимента с новой технологией.
Ни в коем случае нельзя основывать новый большой проект на новых и плохо изученных технологиях.
Иначе придется доделывать эти технологии самому.&lt;/p&gt;

&lt;p&gt;Новые непроверенные технологии я называю хипстерские. 
Именно молодые люди в виду неопытности и плохого знакомства со старыми решениями, тащат в проект новое неопробованное, плохо понимая в чем преимущество нового, кроме удовольствия от новизны.&lt;/p&gt;</content><author><name></name></author><summary type="html">Сложно выбрать технологии для нового проекта. Если смотреть на типичную админку, то надо выбрать: Базу данных, где вы будете хранить данные Сервер приложений, то как вы будете обрабатывать данные на сервере Браузерные технологии, Angular там или React, или все отрендарите на сервере</summary></entry><entry><title type="html">Kotlin: Функции</title><link href="http://yamakarov.ru/kotlin/2018/09/11/kotlin-functions.html" rel="alternate" type="text/html" title="Kotlin: Функции" /><published>2018-09-11T17:37:00+03:00</published><updated>2018-09-11T17:37:00+03:00</updated><id>http://yamakarov.ru/kotlin/2018/09/11/kotlin-functions</id><content type="html" xml:base="http://yamakarov.ru/kotlin/2018/09/11/kotlin-functions.html">&lt;p&gt;Kotlin - набирающий популярность язык от компании JetBrains.&lt;/p&gt;

&lt;p&gt;Я слышал много положительных отзывов об этом языке.&lt;/p&gt;

&lt;p&gt;Пару дней для развлечения пишу маленькие задачки на &lt;a href=&quot;https://try.kotlinlang.org/&quot;&gt;try.kotlinlang.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Сначала было очень непривычно и казалось, что в Kotlin нет ничего такого, ради чего надо было бы учить этот язык.
Нет мощной системы типов как в Haskell, нет макросов как в Lisp, нет полных по Тьюрингу шаблонов как в C++.
К тому же язык выполняется на JVM и ему еще надо доказывать чем он лучше Java и других сильных конкурентов, Scala и Clojure.&lt;/p&gt;

&lt;p&gt;Немного поизучав Kotlin я нашел следующие очень интересные моменты из-за которых складывается впечатления, что язык достоин внимания:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data классы очень удобно использовать в ентерпрайзе и разного рода админках&lt;/li&gt;
  &lt;li&gt;Properties всевозможных видов, позволяющие легко задавать поведение полей и кастомизировать&lt;/li&gt;
  &lt;li&gt;Очень удобное переопределение операторов полезное для написания разного рода dsl,&lt;/li&gt;
  &lt;li&gt;Множестов способов задать функцию, приятные средства для задания анонимных и лямбда функций, а так же специальные кейсы для функций, которые  имеют один аргумент или являются единственным выражением&lt;/li&gt;
  &lt;li&gt;Destructuring параметров&lt;/li&gt;
  &lt;li&gt;Возможно добавлять методы к уже существующим классам&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Это то, что с чем я столкнулся за час изучения Kotlin и те вещи которые мне очень понравились, действительно складывается впечатления, что его писали люди, желающие значительно ускорить промышленную разработку. 
Кажется, что с его помощью можно делать жестко оптимизированные решения заточенные на скорость, благодаря системе типов и плотной интеграции с JVM.
А тем кто хочет сделать гибкое решение для многих пользователей или написать прототип, должна быть полезна выразительность и динамичность языка, для этого есть поддержка.&lt;/p&gt;

&lt;p&gt;Также надо смотреть на нативный и браузерный варианты, которые позволяют переиспользовать код вне JVM окружения.&lt;/p&gt;</content><author><name></name></author><summary type="html">Kotlin - набирающий популярность язык от компании JetBrains.</summary></entry><entry><title type="html">Серверная генерация html страниц</title><link href="http://yamakarov.ru/web-development/2018/09/10/ssr.html" rel="alternate" type="text/html" title="Серверная генерация html страниц" /><published>2018-09-10T17:19:00+03:00</published><updated>2018-09-10T17:19:00+03:00</updated><id>http://yamakarov.ru/web-development/2018/09/10/ssr</id><content type="html" xml:base="http://yamakarov.ru/web-development/2018/09/10/ssr.html">&lt;p&gt;В последнее время большую популярность в web разработке приобрело создание одностраничных приложений.
На Javascript пишется весь пользовательский интерфейс, который отправляет http запросы на сервер и получает данные в формате json.
Такая технология позволяет отделить разработку клиентской части от разработки серверной части и этим я объясняю успех подобных приложений в больших компаниях.
Когда я сам разрабатываю одностраничные приложения меня не покидает мысль, что я что-то делаю не так.
Приходится во многом дублировать логику обработки сущностей.
На текущем проекте, мы используем Java на сервере и Typescript на клиенте и мне приходится описывать http обработчики на Java.
При переходе в браузерный Typescript, информация об описанных обработчиках полностью теряется и приходится снова описывать способы доступа к ним.
Описание полей сущностей дублируется в коде на сервере и на клиенте.
Этой проблемы не было, когда мы использовали Javascript.
Но оказалось, что гораздо лучше продублировать код, чем остаться без такого мощного средства проверки программы, как статическая типизация.&lt;/p&gt;

&lt;p&gt;Я вижу два способа избавиться от дублирования.&lt;/p&gt;

&lt;p&gt;Первый это использовать Kotlin и компилировать модель в Java и Javascript, а также использовать интерфейсы обработчиков в клиентской и серверной частях приложения.
Второй способ это отказаться от работы с Dom в браузере и делать инкрементный рендеринг страниц на сервере.
Это я и называю серверной генерацией страниц.
У этого метода есть ряд преимуществ:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Рендеринг на сервере снимает нагрузку с клиента, что критично, например, на слабых телефонах&lt;/li&gt;
  &lt;li&gt;Упрощает индексацию страниц поисковиками&lt;/li&gt;
  &lt;li&gt;Ускоряет время отображения страницы, не надо дожидаться загрузки Javascript, компиляции и построения дерева&lt;/li&gt;
  &lt;li&gt;Приложение становится легче тестировать&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;К минусам я могу отнести повышение требований к производительности серверной части и усложнение развертывания приложения.&lt;/p&gt;

&lt;p&gt;Я обязательно попробую применить этот метод в своем новом проекте.&lt;/p&gt;</content><author><name></name></author><summary type="html">В последнее время большую популярность в web разработке приобрело создание одностраничных приложений. На Javascript пишется весь пользовательский интерфейс, который отправляет http запросы на сервер и получает данные в формате json. Такая технология позволяет отделить разработку клиентской части от разработки серверной части и этим я объясняю успех подобных приложений в больших компаниях. Когда я сам разрабатываю одностраничные приложения меня не покидает мысль, что я что-то делаю не так. Приходится во многом дублировать логику обработки сущностей. На текущем проекте, мы используем Java на сервере и Typescript на клиенте и мне приходится описывать http обработчики на Java. При переходе в браузерный Typescript, информация об описанных обработчиках полностью теряется и приходится снова описывать способы доступа к ним. Описание полей сущностей дублируется в коде на сервере и на клиенте. Этой проблемы не было, когда мы использовали Javascript. Но оказалось, что гораздо лучше продублировать код, чем остаться без такого мощного средства проверки программы, как статическая типизация.</summary></entry><entry><title type="html">Что такое корректность программы?</title><link href="http://yamakarov.ru/software/2018/09/07/programm-proof.html" rel="alternate" type="text/html" title="Что такое корректность программы?" /><published>2018-09-07T15:03:00+03:00</published><updated>2018-09-07T15:03:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/07/programm-proof</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/07/programm-proof.html">&lt;p&gt;В одном из своих &lt;a href=&quot;/cs/2018/08/10/program-proofs.html&quot;&gt;постов&lt;/a&gt; я упоминал, что считаю доказательство корректности программы перспективным методом ускорения разработки за счет устранения ошибок, уменьшения времени отлаживания программы и снижения издержек во время эксплуатации за счет уменьшения числа найденных ошибок после запуска.&lt;/p&gt;

&lt;p&gt;На практике доказывать программы оказывается довольно непривычно.
Для этого нужно понять, что мы хотим доказать.
Формулировка: Мы хотим доказать, что программа работает правильно, является крайне расплывчатой.
Не помогает заменить правильность на отсутствие ошибок, так как это, очевидно, тавтология.&lt;/p&gt;

&lt;p&gt;Чтобы что-то доказать, мы должны сформулировать теоремы, которые собственно и будем доказывать.&lt;/p&gt;

&lt;p&gt;Я встречался в статьях со следующими формулировками:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Доказать, что цикл завершается у Дейкстры&lt;/li&gt;
  &lt;li&gt;Доказательство, что определенная формула верна, например частное умножить на делитель плюс остаток равно исходному числу у Хоара&lt;/li&gt;
  &lt;li&gt;Доказательство свойства взаимного исключения, отсутствия дедлоков и живучести алгоритмов синхронизации у Лампорта&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Таким образом, когда у нас есть определенная программа мы должны определить интересные нам свойства и доказать, что они выполняются.
В этом плане довольно просто доказывать функции без побочных эффектов.
Нам надо чтобы за конечное число шагов такая функция получила результат, а значит надо доказать:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Асимптотику выполнения программы, за О каких шагов выполнится алгоритм&lt;/li&gt;
  &lt;li&gt;Доказать, что выходные значения будут удовлетворять некоторой формуле, входит в какие-то множества и так далее&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Программы с побочными эффектами будут несколько сложнее, но кажется если в исходные параметры и в результаты добавить внешнюю систему, то можно доказывать тоже самое.&lt;/p&gt;</content><author><name></name></author><summary type="html">В одном из своих постов я упоминал, что считаю доказательство корректности программы перспективным методом ускорения разработки за счет устранения ошибок, уменьшения времени отлаживания программы и снижения издержек во время эксплуатации за счет уменьшения числа найденных ошибок после запуска.</summary></entry><entry><title type="html">Один за всех</title><link href="http://yamakarov.ru/software/2018/09/06/laguage.html" rel="alternate" type="text/html" title="Один за всех" /><published>2018-09-06T19:18:00+03:00</published><updated>2018-09-06T19:18:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/06/laguage</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/06/laguage.html">&lt;p&gt;У меня есть смутное подозрение, что использование одного языка для написания проекта является большим благом.
Когда разработчику приходится разбираться в коде на нескольких языках он теряется.
Гораздо проще и понятнее работать с идиомами одного языка.
И в этом плане мне очень понравилось писать на Clojure.
Я верстал страницы и делал серверные обработчики на одном языке.
Фронтенд пришлось писать на других языках, но это была моя слабость.
Он вообще славится полифонией языков, html, css, javascript и т.д.&lt;/p&gt;

&lt;p&gt;Не понимаю почему так произошло, но мне кажется это неправильный путь.
Гораздо лучше писать на одном языке.
При этом может возникнуть проблема.
В разных средах исполнения у языка будет разная семантика, но я думаю как раз это некритично.&lt;/p&gt;

&lt;p&gt;Я не хочу использовать Clojure, потому что это язык без статической проверки типов.
Мне кажется в большой командной разработке обязательно использовать по крайней мере строго типизированный язык.&lt;/p&gt;

&lt;p&gt;Некоторые используют Haskell и OCaml. 
Но я пытался и пришел к выводу, что они слишком академичные и не готовы к промышленному использованию.
Да иногда получается сделать на них очень хорошие вещи, но для этого нужен подлинный энтузиаст, который готов несмотря ни на что фиксить проблемы использования языка.&lt;/p&gt;

&lt;p&gt;Опять же таки в Haskell, очень много заумных идей и заумное сообщество, из-за чего программирование на нем превращается в непрерывное увлекательное чтение статей с переднего края разработки языков.
Я не знаю к сожалению C и С++, они имеют свою область применения. Мне гораздо ближе Java.&lt;/p&gt;

&lt;p&gt;Java слишком многословна, и GWT которым можно было компилировать Java в Javascript провалился. 
Больно долго он это делал и имел плохую интеграцию с браузерами.&lt;/p&gt;

&lt;p&gt;В качестве конкурента Java на мой взгляд выступает только Kotlin, который активно развивается и имеет хорошую поддержку от JetBrains.
Это интересный язык, но я пока так и не смог найти очевидные преимущества Kotlin в выразительной силе перед Java.&lt;/p&gt;</content><author><name></name></author><summary type="html">У меня есть смутное подозрение, что использование одного языка для написания проекта является большим благом. Когда разработчику приходится разбираться в коде на нескольких языках он теряется. Гораздо проще и понятнее работать с идиомами одного языка. И в этом плане мне очень понравилось писать на Clojure. Я верстал страницы и делал серверные обработчики на одном языке. Фронтенд пришлось писать на других языках, но это была моя слабость. Он вообще славится полифонией языков, html, css, javascript и т.д.</summary></entry><entry><title type="html">Погружаемся! Где остановиться, когда идешь на дно?</title><link href="http://yamakarov.ru/software/2018/09/05/go-deeper.html" rel="alternate" type="text/html" title="Погружаемся! Где остановиться, когда идешь на дно?" /><published>2018-09-05T11:20:00+03:00</published><updated>2018-09-05T11:20:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/05/go-deeper</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/05/go-deeper.html">&lt;p&gt;Программное обеспечение состоит из &lt;a href=&quot;/architecture/2018/08/20/layer-architecture.html&quot;&gt;слоев&lt;/a&gt;. 
Каждый слой имеет определенный интерфейс.
Когда мы используем интерфейс и встречаемся с ошибкой в этом интерфейсе, мы должны разобраться в реализации и опуститься на слой ниже.
Даже если нет никаких ошибок, есть определенные ограничения.
Они лежат за пределами интерфейса текущего уровня.&lt;/p&gt;

&lt;p&gt;Чтобы понимать эти ограничения надо опускаться на уровень ниже. 
Например в нашем web-приложении мы ограничены в числе запросов обрабатываемых в секунду времени.
Тогда нам нужно разбираться со Spring, чтобы увеличить это количество. 
Spring это для примера, на его место не умоляя общности можно поставить любую другую надстройку над http сервером.
Когда мы выжали все что можно из наших сервлетов и Spring, нам нужно оптимизировать http сервер.
Если с сервером мы тоже справились, можно идти дальше и разбираться с системными вызовами к сетевому оборудованию, с работой с сокетами.
Когда на уровне сокетов мы выжали все что можем в операционной системе, мы можем улучшить физические сетевые адаптеры.
Разобравшись с сетевыми картами, мы можем изменить разобраться с физикой процессов передачи информации и сделать оптоволоконные кабели, вместо медных и заменить процессоры.
В физике, можно опускаться еще ниже и ниже, до ядерной и квантовой физики для создания выдающихся новых технологий.&lt;/p&gt;

&lt;p&gt;На моем опыте, средним по силе программист считается, если хорошо разбирается в коде своего уровня и умеет опускаться хотя бы на уровень ниже.
Более менее сильным программист становится, если доходит до двух трех уровней вниз, где-то до базовых протоколов взаимодействия. 
Http в моем случае.
Классным специалист считается, когда он знает досконально все начиная с инферфейса железа, далее операционной системы и далее.
Может оттрейсить выполнение алгоритма до машинных команд.&lt;/p&gt;

&lt;p&gt;Дальше в принципе уже достаточно общего понимания физики транзисторов и их работы, чтобы хорошо программировать, на мой взгляд не надо уметь проектировать процессоры.
Программирование и разводка микросхем ортогональные навыки.
Может быть это потому, что я не работал в компаниях уровня Google.&lt;/p&gt;

&lt;p&gt;Там ребята для обучения AlphaGo  запилили собственный кластер, ПО для этого кластера и специализированные TPU устройства для обучения нейронных сетей. И это очень круто, особенно учитывая что развитие процессоров общего назначения остановилось.
И в будущем будет расти число узкоспециализированных устройств, проектирование которых будет упрощаться и время от проекта до использования уменьшаться. 
Особенно показателен в этом плане приме Asic устройств для майнинга биткоинов.&lt;/p&gt;</content><author><name></name></author><summary type="html">Программное обеспечение состоит из слоев. Каждый слой имеет определенный интерфейс. Когда мы используем интерфейс и встречаемся с ошибкой в этом интерфейсе, мы должны разобраться в реализации и опуститься на слой ниже. Даже если нет никаких ошибок, есть определенные ограничения. Они лежат за пределами интерфейса текущего уровня.</summary></entry></feed>