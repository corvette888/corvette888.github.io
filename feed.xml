<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://yamakarov.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="http://yamakarov.ru/" rel="alternate" type="text/html" /><updated>2018-09-27T18:50:06+03:00</updated><id>http://yamakarov.ru/</id><title type="html">Записки Java программиста</title><subtitle>Блог о разработке web админок, CRM-ок и прочего. 
</subtitle><entry><title type="html">Ускоряем Jekyll с помощью Kotlin</title><link href="http://yamakarov.ru/kotlin/jekyll/2018/09/27/kotlin-jekyll.html" rel="alternate" type="text/html" title="Ускоряем Jekyll с помощью Kotlin" /><published>2018-09-27T18:24:00+03:00</published><updated>2018-09-27T18:24:00+03:00</updated><id>http://yamakarov.ru/kotlin/jekyll/2018/09/27/kotlin-jekyll</id><content type="html" xml:base="http://yamakarov.ru/kotlin/jekyll/2018/09/27/kotlin-jekyll.html">&lt;p&gt;Одним из первых постов в этот блог был пост про &lt;a href=&quot;/java/jekyll/2018/04/09/jekyll-boost.html&quot;&gt;ускорение работы с Jekyll с помощью Java&lt;/a&gt;.
Там я писал, что:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Я засек время потраченное на написание программы 34 минуты. Мне надо сделать около 50 постов, чтобы оно окупилось, и надо чтобы в программе не нашлось новых багов.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Я написал эти 50 постов. Сейчас в блоге 125 записей.
И эксперимент оказался очень &lt;a href=&quot;/commandline/2018/09/17/command-line-power.html&quot;&gt;удачным&lt;/a&gt;.
Я решил продолжить его перевести программу для генерации постов с Java на Kotlin.
Это оказалось очень просто, IntelliJ IDEA умеет делать это автоматически:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot; data-lang=&quot;kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;ru.yamakarov.jekyll&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.io.IOException&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.nio.file.FileSystems&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.nio.file.Files&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.text.SimpleDateFormat&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.*&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;No command do nothing\n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;possible options:\n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;-n name  Creates new post \n&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;---\n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;layout: post\n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;title:  \&quot;\&quot;\n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;date:   &quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleDateFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy-MM-dd HH:mm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;\n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;categories: \n&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;---\n\n&quot;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;fileName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimpleDateFormat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yyyy-MM-dd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
                &lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.markdown&quot;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FileSystems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;_posts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;fileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listOf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fileName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IOException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Exception writing file&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Оказалось очень удобно.
Хочется отметить следующие моменты:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;На Kotlin можно писать один в один как на Java. 
Это не значит, что нужно так делать. Но то, что можно очень хорошо. Существенно упрощает переход на новый язык.&lt;/li&gt;
  &lt;li&gt;Я не знал, но оказывается можно не ставить точку с запятой в конце утверждения&lt;/li&gt;
  &lt;li&gt;В IDEA работает &lt;code class=&quot;highlighter-rouge&quot;&gt;sout&lt;/code&gt; тоже удобно для тех, кто переходит с Java&lt;/li&gt;
  &lt;li&gt;В сконвертированной программе нет ни одного объявления типа, а значит не надо писать Борщ борщ = new Борщ(), это удобно на мой взгляд.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Одним из первых постов в этот блог был пост про ускорение работы с Jekyll с помощью Java. Там я писал, что:</summary></entry><entry><title type="html">Области применения автоматного программирования</title><link href="http://yamakarov.ru/software/automata/2018/09/26/automata-domain.html" rel="alternate" type="text/html" title="Области применения автоматного программирования" /><published>2018-09-26T19:20:00+03:00</published><updated>2018-09-26T19:20:00+03:00</updated><id>http://yamakarov.ru/software/automata/2018/09/26/automata-domain</id><content type="html" xml:base="http://yamakarov.ru/software/automata/2018/09/26/automata-domain.html">&lt;p&gt;Как только я начал разбираться в том, как работает автоматное программирование, стали появляться различные приложения для этого подхода.&lt;/p&gt;

&lt;p&gt;Статья &lt;a href=&quot;Как не выстрелить себе в ногу из конечного автомата&quot;&gt;Как не выстрелить себе в ногу из конечного автомата&lt;/a&gt; описывает применение автоматного программирования при разработке iOS приложений. Оказывается удобным в этой концепции описывать список статей с комментариями.&lt;/p&gt;

&lt;p&gt;Автоматное программирование с разной степенью успешности применяют для разработки javascript виджетов. 
Эта область применения мне кажется очень перспективной.
Состояния позволяют рассуждать о поведении виджета при различных событиях.&lt;/p&gt;

&lt;p&gt;Лампорт пишет, что использовал автоматы для описания распределенных систем в &lt;a href=&quot;https://www.microsoft.com/en-us/research/publication/time-clocks-ordering-events-distributed-system/?from=http%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fum%2Fpeople%2Flamport%2Fpubs%2Ftime-clocks.pdf&quot;&gt;Time, Clocks, and the Ordering of Events in a Distributed System&lt;/a&gt; Правда, он пишет что использование автоматов никто не заметил, и шутит, что он специально перечитал свою статью, чтобы убедиться в том, что он действительно написал.
Состояния я встречал в другой статье Лампорта &lt;a href=&quot;https://lamport.azurewebsites.net/pubs/fast-mutex.ps&quot;&gt;A Fast Mutual Exclusion Algorithm&lt;/a&gt;.
Там они используются для доказательства корректности программы. 
После каждой строчки исполнения агенты, исполняющие алгоритм синхронизации попадают в определенное состояние, которое характеризуется набором условий. Таким образом мы можем рассматривать любую программу как конечный автомат. 
И вроде как не сам Лампорт это придумал, а есть отсылки к Susan Owicki and David Gries. An axiomatic proof technique for parallel programs.
Таким образом автоматы могут быть очень удобны для доказательства различных алгоритмов синхронизации.&lt;/p&gt;

&lt;p&gt;Также в распределенных системах хорошо себя зарекомендовал протокольный подход.
И протоколы, кажется, неплохо верифицируются с помощью автоматов.&lt;/p&gt;

&lt;p&gt;К тому же, автоматы неплохо соответствуют тому, как работает процессор.&lt;/p&gt;

&lt;p&gt;Одной из основных областей применения автоматов является разработка компиляторов.
Регулярные выражения на них основаны.&lt;/p&gt;

&lt;p&gt;Они очень неплохо поддаются визуализации, что может быть и вредит им. 
Так как привело к большому количеству попыток создания визуальных средств программирования.&lt;/p&gt;

&lt;p&gt;Существуют примеры использования автоматного программирования с помощью MPS от IDEA.&lt;/p&gt;

&lt;p&gt;Я сам начал пытаться применять идею состояний и событий к разработке компонент на Angular и очень доволен получаемыми результатами.&lt;/p&gt;</content><author><name></name></author><summary type="html">Как только я начал разбираться в том, как работает автоматное программирование, стали появляться различные приложения для этого подхода.</summary></entry><entry><title type="html">Автоматное программирование</title><link href="http://yamakarov.ru/software/2018/09/25/switch-programming.html" rel="alternate" type="text/html" title="Автоматное программирование" /><published>2018-09-25T17:30:00+03:00</published><updated>2018-09-25T17:30:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/25/switch-programming</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/25/switch-programming.html">&lt;p&gt;Сегодня изучал работы &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%BB%D1%8B%D1%82%D0%BE,_%D0%90%D0%BD%D0%B0%D1%82%D0%BE%D0%BB%D0%B8%D0%B9_%D0%90%D0%B1%D1%80%D0%B0%D0%BC%D0%BE%D0%B2%D0%B8%D1%87&quot;&gt;Шалыто&lt;/a&gt; посвященные автоматному программированию.
Эта технология кажется перспективной.
Однако на мой вкус представлена из рук вон плохо, я например стал чуть-чуть понимать суть только с третьего подхода.
Даже функциональное программирование и теорию категорий, кажется проще освоить.&lt;/p&gt;

&lt;p&gt;Идея автоматного программирования заключается в построении управляющего автомата.
Для этой цели программа описывается, как набор состояний, событий и переходов между состояниями.&lt;/p&gt;

&lt;p&gt;В статьях про &lt;a href=&quot;http://is.ifmo.ru/automata/&quot;&gt;автоматное программирование&lt;/a&gt; с сайта университета ИТМО приводятся примеры использования
автоматного программирования для разработки микроконтроллеров.&lt;/p&gt;

&lt;p&gt;Сам Шалыто в своих статьях упирает на то, что использовать автоматное программирование надо повсеместно.
Такие программы проще в отладке и подаются неведомому мне Model Checking.&lt;/p&gt;

&lt;p&gt;Это полностью укладывается в мою вчерашнюю фразу по &lt;a href=&quot;/software/2018/09/24/programmer-job.html&quot;&gt;интереснyю концепцию&lt;/a&gt;  написания программ. 
По-видимому это были отголоски предыдущих попыток осознать автоматное программирование.&lt;/p&gt;

&lt;p&gt;Мне кажутся перспективными следующие моменты:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Идея состояний - четко выделив состояния, мы можем определить так называемое фазовое пространство системы и в нем доказывать разные свойства, обычно состояние в программе не выделяется и на осознается, от этого не понятны краевые условия. Они не понятны и не проверяются, а в эксплуатации из-за этого происходят ошибки.&lt;/li&gt;
  &lt;li&gt;Идея событий - события это очень модная сейчас тема, которая под вывеской реактивного программирования переходит из UI в серверное программирование. Если совместить события с состояниями, то получается очень мощная концепция разработки, которая не раз помогала мне в решении различных багов при многопоточном программировании. Когда мы выделяем события, мы тем самым определяем что может произойти в системе. Выделив события мы чисто формально можем создать цепочки событий и применить их к выделенным состояниям. И в этом случае становится просто убедиться, что отсутствуют ошибки при любых событиях в любых состояниях. 
Если же ошибка все таки находится, это значит только что мы неправильно определили состояния или не учли все события.&lt;/li&gt;
  &lt;li&gt;События и состояния недостаточны для моделирования окружающего мира, поэтому в автоматном программировании используются обработчики переходов из состояния в состояние.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Даже базовое примение этих концепций, без формальных доказательств, приводи к упрощению  по крайней мере разработки пользовательских интерфейсов.
Это странно, но я вижу несколько причин недостаточного развития автоматного программирования:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Авторы упирают на графические интерфейсы, что не есть гуд. Опыт показал, что текстовое представление предпочтительней.&lt;/li&gt;
  &lt;li&gt;Большое количество примеров касается лифта, что не является классическим примером для программирования, по-видимому школа ИТМО не заморачивалась сильно на пользовательские интерфейсы, или я еще не нашел нужных данных.&lt;/li&gt;
  &lt;li&gt;Возможно, просто не нашелся герой, который двинет автоматное программирование в массы.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Сегодня изучал работы Шалыто посвященные автоматному программированию. Эта технология кажется перспективной. Однако на мой вкус представлена из рук вон плохо, я например стал чуть-чуть понимать суть только с третьего подхода. Даже функциональное программирование и теорию категорий, кажется проще освоить.</summary></entry><entry><title type="html">Работа программиста</title><link href="http://yamakarov.ru/software/2018/09/24/programmer-job.html" rel="alternate" type="text/html" title="Работа программиста" /><published>2018-09-24T18:26:00+03:00</published><updated>2018-09-24T18:26:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/24/programmer-job</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/24/programmer-job.html">&lt;p&gt;Я довольно долго занимаюсь написание программ.
Уже лет 20 точно.
И только недавно осознал, как писать надежные программы.
Это банально, но чтобы программа не содержала ошибок, надо рассмотреть все возможные входные данные и доказать что определенные свойства будут выполнены.
Сейчас я так не делаю, я пишу программу и начинаю тестировать.
Тестирование выявляет проблемы, которые я правлю и продолжаю тестирование.
Поэтому я посредственный программист.&lt;/p&gt;

&lt;p&gt;У меня есть одно небольшое оправдание.
В книгах о технологиях обычно опускается разбор краевых случаев и обработка ошибок.
Эти вещи существенно увеличивают кодовую базу и отвлекают читателя от главной идеи, затрудняя ее понимание.
Поэтому по книжкам трудно научиться промышленному программированию.&lt;/p&gt;

&lt;p&gt;Но и в процессе работы, учиться хорошим практиками довольно тяжело.
Большое количество софта имеет очень низкие требования к качеству.
Часто нужно, чтобы оно хоть как-то работало, а люди уж смогут приспособиться и обходить ошибки в программе.
Во всяком случае, я умудрился 15 лет писать программное обеспечение и ни разу не видел, чтобы проекты провалились из-за низкого качества.
Но то моя специфика, возможно в космической, финансовой и медицинской сферах по другому.
Хотя, насколько я знаю, доказательное программирование повсеместно заменяется более тщательным тестированием.
Чем больше тестируешь, тем меньше багов останется.
Главное, чтобы фиксы багов не плодили новых багов.
А то бывают программисты у которых этот процесс не сходится, ну или очень медленно сходится.&lt;/p&gt;

&lt;p&gt;Есть простые вещи. 
Например, раньше я бывало писал бесконечные циклы.
Но с тех, пор как я узнал что существуют инварианты циклов и стал в цикле сначала писать уменьшение переменной цикла, а потом уже тело цикла, это проблема почти мне не встречается.&lt;/p&gt;

&lt;p&gt;А вот с NPE я так и не поборолся, они регулярно выскакивают в моем коде.
Хотя кажется, чего уж проще. 
Можно расставить аннотации и заставить IDE проверять на возможное null значение.&lt;/p&gt;

&lt;p&gt;Интересной концепцией для формулирования свойств программы особенно в пользовательском интерфейсе, мне кажется идея состояний.
Когда пишется компонент, надо сформулировать набор состояний в которых он может прибывать.
Дальше по осуществлению тех или иных событий фиксировать переходы из одного состояния в другое.
Если к каждому состоянию привязать состояние входящих компонент, мы получим консистентное состояние системы.&lt;/p&gt;</content><author><name></name></author><summary type="html">Я довольно долго занимаюсь написание программ. Уже лет 20 точно. И только недавно осознал, как писать надежные программы. Это банально, но чтобы программа не содержала ошибок, надо рассмотреть все возможные входные данные и доказать что определенные свойства будут выполнены. Сейчас я так не делаю, я пишу программу и начинаю тестировать. Тестирование выявляет проблемы, которые я правлю и продолжаю тестирование. Поэтому я посредственный программист.</summary></entry><entry><title type="html">Опыт в программировании</title><link href="http://yamakarov.ru/software/2018/09/21/programming-experience.html" rel="alternate" type="text/html" title="Опыт в программировании" /><published>2018-09-21T18:16:00+03:00</published><updated>2018-09-21T18:16:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/21/programming-experience</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/21/programming-experience.html">&lt;p&gt;Мне как взрослеющему или даже стареющему программисту приходится задумываться о том, чем я лучше молодых программистов.
И лучше ли на самом деле.
Есть определенный круг задач, с которыми я справляюсь очень плохо.
Это некие рутинные работы, повторение того, что уже было когда-то сделано.
И я плохо решаю супер сложные задания, в которых требуется высокая концентрация и есть большой риск неудачи.
Хорошо мне даются средней сложности задачи, желательно чтобы что-то подобные я уже делал раньше.
Может быть поэтому я и занимаюсь админками.
Они очень похожи друг на друга, и если хочется то можно пытаться автоматизировать рутинную работу.&lt;/p&gt;

&lt;p&gt;Смотря на молодых разработчиков, я вижу у них следующие недостатки:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Они могут просто не знать о некоторых областях программирования. 
Например я встречался с тем, что хорошие молодые разработчики совершенно ничего не знают про SQL, и там где можно решить задачу одной строчкой городят целый лес.
Или наоборот пишут многоэтажный SQL там где хорошо бы этого не делать, чтобы не размазывать логику и не нагружать базу данных. 
Наверное, это относится к кругозору и общей начитанности и до определенного времени просто нельзя разобраться во всех необходимых областях.
На мой взгляд при должном старании на устранения этого недостатка требуется 3-5 лет.&lt;/li&gt;
  &lt;li&gt;Молодые разработчики могут не уметь работать в команде.
Просто не понимают, как правильно взаимодействовать с начальством и коллегами. 
Тут может потребоваться довольно много времени на то, чтобы овладеть этим навыками. 
Это может приводить к частой смене работы.
Может никогда не закончиться, а может человек этому научится еще в детском саду или школе или институте.&lt;/li&gt;
  &lt;li&gt;Неопытные разработчики могут быть крайне самонадеянны, но не факт что это недостаток. 
Некоторые задачи требуют определенного уровня безответственности, чрезмерной самоуверенности.
Но таких задач мало.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Но у начинающих программистов есть и очевидные достоинства:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Часто они очень быстро соображают. В свои 37 я начал замечать замедленее в соображалке. 
В первый раз я это осознал, когда долго и вдумчиво читал инструкцию к лифту. 
Раньше со мной такого не было.&lt;/li&gt;
  &lt;li&gt;Они открыты всему новому, легче испытывают энтузиазм по поводу новых технологий. 
При &lt;a href=&quot;/software/2018/09/12/hipster-tech.html&quot;&gt;чрезмерном употреблении&lt;/a&gt; это может приводить к проблемам. 
Но дозировано помогает освоить новый материал.&lt;/li&gt;
  &lt;li&gt;В зависимости от ситуации большим плюсом может быть их управляемость. 
Частенько менеджеру гораздо проще общаться с молодыми специалистами.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Все это довольно общие замечания.
Конкретно, я бы хотел добавить, что очень важным для программиста является владение методами.
Важно иметь в своим арсенале множество способов решения задачи, чтобы из них можно было выбрать.
Насколько я понимаю, овладение одним методом ведет к упрощению овладения другим.
Поэтому достаточно интересные результаты получаются у людей в любом возрасте.
И к сожалению, люди часто останавливаются в этом процессе.
Находят один способ и успокаиваются, огорчаются лишь тогда когда метод перестает работать, а новый освоить очень сложно.&lt;/p&gt;</content><author><name></name></author><summary type="html">Мне как взрослеющему или даже стареющему программисту приходится задумываться о том, чем я лучше молодых программистов. И лучше ли на самом деле. Есть определенный круг задач, с которыми я справляюсь очень плохо. Это некие рутинные работы, повторение того, что уже было когда-то сделано. И я плохо решаю супер сложные задания, в которых требуется высокая концентрация и есть большой риск неудачи. Хорошо мне даются средней сложности задачи, желательно чтобы что-то подобные я уже делал раньше. Может быть поэтому я и занимаюсь админками. Они очень похожи друг на друга, и если хочется то можно пытаться автоматизировать рутинную работу.</summary></entry><entry><title type="html">Сроки разработки</title><link href="http://yamakarov.ru/software/2018/09/20/development-time.html" rel="alternate" type="text/html" title="Сроки разработки" /><published>2018-09-20T19:34:00+03:00</published><updated>2018-09-20T19:34:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/20/development-time</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/20/development-time.html">&lt;p&gt;Человеческая жизнь ограничена.
И люди могут достичь конечное количество целей.
Может быть с этим связано то, что мы хотим знать когда та или иная работа закончится.&lt;/p&gt;

&lt;p&gt;Достижение каких-то целей легко оценить.
Например легко оценить сколько времени у вас займет поход в парикмахерскую.
Хотя и тут бывают казусы.
Очень сложно оценить сколько времени будет идти строительство.
В процессе часто появляются новые данные, которые смещают сроки сдачи.&lt;/p&gt;

&lt;p&gt;В программировании оценить сроки очень сложно.
Есть несколько причин затягивания сроков:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Добавление требований в процессе разработки&lt;/li&gt;
  &lt;li&gt;Появление новых знаний о предмете&lt;/li&gt;
  &lt;li&gt;Интеграция с другими сервисами&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Начнем с добавления новых требований. 
Ведь что такое программирование? 
Это полная детализация задачи, так чтобы ее мог выполнить компьютер.
Человек легко справляется со многими задачами, даже не понимая как он это делает.
Мы очень часто руководствуемся декларативным целеуказанием.
Человеку достаточно знать, что надо купить билет.
Компьютер же уже нужен подробный план действий вплоть до мельчайших подробностей, транзисторов и битиков летящих по проводам.
И поэтому когда заказчик выдвигает требование, он может не осознать степень декларативности своих указаний.
В процессе разработки это конечно всплывет и окажется, что такая простая для человека задача, как купить билет, для компьютера практически невыполнима.
И тогда приходится как-то ее решать уточнять и рассматривать частные случаи, что не всегда устраивает заказчика и он требует переделать, а это и ведет к расширению требований.&lt;/p&gt;

&lt;p&gt;Связано с этим и расширение знаний о предмете, декларативные знания переходят в императивные и иногда так получается, что тонкий нюанс увеличивает время разработки на порядки.
Хорошо, когда разработчик внимателен к деталям и может построить императивный план достаточно близкий к реальности.
У меня с этим совсем туго, частенько я поверхностно оцениваю декларативное описание задачи.
Итеративная разработка очень помогает решить проблему, после каждой итерации программы становятся все более подробными и в конце концов можно точно оценить сроки следующей итерации.&lt;/p&gt;

&lt;p&gt;Третий пункт также упирается в недостаточность знаний о предмете.
По-моему, так называемый “кровавый энтерпрайз” кровавый, потому что требует взаимодействия со многими внешними системами, с плохой документацией и кучей багов.
Когда пишется ПО для взаимодействия со внешней системой, для это внешней системы строится модель.
Эта модель может очень сильно отличаться от реальности и это приводит к необходимости сильно переделывать программу.&lt;/p&gt;

&lt;p&gt;Надо отчетливо понимать степень декларативности текущего алгоритма решения задачи, и там где все крайне абстрактно быть крайне осторожным.&lt;/p&gt;</content><author><name></name></author><summary type="html">Человеческая жизнь ограничена. И люди могут достичь конечное количество целей. Может быть с этим связано то, что мы хотим знать когда та или иная работа закончится.</summary></entry><entry><title type="html">Выдающиеся люди в программировании</title><link href="http://yamakarov.ru/software/2018/09/19/outstanding-people.html" rel="alternate" type="text/html" title="Выдающиеся люди в программировании" /><published>2018-09-19T18:25:00+03:00</published><updated>2018-09-19T18:25:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/19/outstanding-people</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/19/outstanding-people.html">&lt;p&gt;Для меня люди двигающие науку программирования вперед были всегда непостижимы.
Я совсем не понимал, как у них получается делать такие крутые штуки.
Теперь я начал немного понимать, как у них это получается.&lt;/p&gt;

&lt;p&gt;Для того, чтобы написать что-то интересное надо иметь светлый ум и большие знания.
Со светлым умом, кому-то повезло, кому-то нет. 
Каждому приходится жить с тем, чем наградила его природа.
Вроде как даже с очень ограниченными мозгами, при достаточной концентрации и упертости можно много чего сделать.
Главное отбросить все лишние, что не у всех получается.
Тут я не уверен в диагнозе, но кажется одержимость идеей и легкая форма шизофрении очень кстати.&lt;/p&gt;

&lt;p&gt;Знания копятся в процессе обучения. 
Самый хороший способ это получать знания от наставника, он поможет решить трудные но не важные проблемы на старте.
Наставник даст направление и укажет материалы, которые необходимо освоить.
Также поддержит в трудную минуту и скорректирует путь.
Лично мне не удалось найти наставника и я стараюсь черпать знания из книг.
Такой способ хорош, при системном подходе, который опять же так может дать наставник, но бессистемное чтение приводит к отрывочным знаниям и неэффективной трате времени.&lt;/p&gt;

&lt;p&gt;Книги хорошо тем, что дают обзор проблемы, а особенно хорошие книги как SICP просто кладезь мудрости на каждой странице.
Большое количество книг содержат довольно много воды, и если вы уже в теми читать их долго и скучно.
Гораздо интереснее читать статьи.&lt;/p&gt;

&lt;p&gt;Но с ними есть определенная сложность. 
Читать все подряд не слишком эффективно. 
Огромное количество статей ни о чем и написаны плохо.
Бывают статьи об интересном достижении, но написана так непонятно, что нет никакой возможности разобраться.
Но в целом это, пожалуй, единственный способ держать руку на пульсе.
Те материалы, которые попали в книги, или уже даже книги переведенные на русский, часто глубоко устарели.
На основе этих данных очень трудно создать что-то новое, все простое уже давно в своих статьях описали последователи, которые почерпнули знания из статей.&lt;/p&gt;

&lt;p&gt;Однако, знания это не все что требуется и не только из статей их можно получать. 
Я уже говорил про наставника - это пример человеческого взаимодействия.
Взаимодействовать можно и в более широком смысле.
Нужно общаться с другими людьми в этой области.
Часто у людей просто нет времени реализовать ту или иную хорошую идею.
Они могут ей только поделиться.
Эту идею можно подхватить развить и отрецензировать.&lt;/p&gt;

&lt;p&gt;Подводя итог, чтобы сделать что-то великое в программировании, нужно много читать, много писать и общаться с великими. 
Читать чтобы знать, писать чтобы получать фидбек, общаться чтобы были идеи.
В принципе, читать и писать достаточно, это уже и есть общение.&lt;/p&gt;</content><author><name></name></author><summary type="html">Для меня люди двигающие науку программирования вперед были всегда непостижимы. Я совсем не понимал, как у них получается делать такие крутые штуки. Теперь я начал немного понимать, как у них это получается.</summary></entry><entry><title type="html">Angular во внутренней разработке</title><link href="http://yamakarov.ru/angular/2018/09/18/angular-pitfalls.html" rel="alternate" type="text/html" title="Angular во внутренней разработке" /><published>2018-09-18T18:13:00+03:00</published><updated>2018-09-18T18:13:00+03:00</updated><id>http://yamakarov.ru/angular/2018/09/18/angular-pitfalls</id><content type="html" xml:base="http://yamakarov.ru/angular/2018/09/18/angular-pitfalls.html">&lt;p&gt;Для внутренней фронтенд разработки мы используем &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;.
Это отличный фреймворк, который существенно ускоряет разработку.
В связке с &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;Typescript&lt;/a&gt; он становится еще мощнее.&lt;/p&gt;

&lt;p&gt;Преимуществом Angular является то, что на нем очень удобно делать компоненты и управлять состоянием.
Идея отслеживать изменения модели и автоматически перерисовывать представление оказывается очень мощной.
Ею легко овладеть.
Несмотря на то, что порог вхождения считается довольно высоким из моего получается, что это не так.
У одного и того же разработчика, на jQuery и Angular получаются очень разные по функциональности компоненты.&lt;/p&gt;

&lt;p&gt;Скажем так, что на jQuery они вообще не получаются, на выходе месиво из разных функций, беспорядочно вызываемых.
В то же время на Angular все разбито на компоненты и более менее упорядочено.&lt;/p&gt;

&lt;p&gt;Но кое за что мне хочется поругать Angular.
В нем довольно сложно переиспользовать компоненты.
Из-за того, что фреймворк нещадно смешивает html и код приложения, трудно отделить верстку от бизнес логики.
И мои приложения получаются сборником довольно разувесистых компонент, которые совсем не комбинируются друг с другом, 
а просто являются отдельными страницами приложения.&lt;/p&gt;

&lt;p&gt;В этом плане мне нравится идея, так сказать перенести рендеринг на сервер.
Там можно строить тот же виртуальный дом, что строится на клиенте при изменении модели и отправлять назад в браузер.
Клиентскому коду останется только собирать ввод пользователя, отправлять на сервер и подставлять в реальный dom, dom отрендаренный на сервере.&lt;/p&gt;

&lt;p&gt;Что это даст?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Клиент будет содержать минимальную, хотя и довольно сложную логику&lt;/li&gt;
  &lt;li&gt;Все компоненты будут строиться, а значит и тестироваться на сервере, тут можно возразить, что тестировать можно и клиентский Angular, но иметь два фреймворка для тестирования хуже чем один и потому тестировать на сервере мне видится проще&lt;/li&gt;
  &lt;li&gt;Такой подход удобен для индексации поисковиками, хотя это и не случай внутренней разработки&lt;/li&gt;
  &lt;li&gt;При генерации html серверными функциями можно пользоваться всею мощью любимой IDE&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Для внутренней фронтенд разработки мы используем Angular. Это отличный фреймворк, который существенно ускоряет разработку. В связке с Typescript он становится еще мощнее.</summary></entry><entry><title type="html">Мощь командной строки</title><link href="http://yamakarov.ru/commandline/2018/09/17/command-line-power.html" rel="alternate" type="text/html" title="Мощь командной строки" /><published>2018-09-17T17:38:00+03:00</published><updated>2018-09-17T17:38:00+03:00</updated><id>http://yamakarov.ru/commandline/2018/09/17/command-line-power</id><content type="html" xml:base="http://yamakarov.ru/commandline/2018/09/17/command-line-power.html">&lt;p&gt;Этот блог я веду с помощью системы &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; и размещаю на &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github pages&lt;/a&gt;.
Я делаю это где-то в течение полугода &lt;a href=&quot;/kotlin/2018/04/08/kotlin-coroutines.html&quot;&gt;первый пост&lt;/a&gt; я написал 8 апреля.
На Github Pages размещаются статические странички моего блога, которые генерятся с помощью Jekyll.
Jekyll позволяет писать сообщения в любом текстовом редакторе.
Я использую Vim.
Это оказалось очень удобно, гораздо удобнее чем писать в каком-либо браузерном редакторе или писать в текстовом редакторе, а потом для постинга переносить в браузер.
Для работы я завел несколько командных скриптов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new-post&lt;/code&gt; для создания нового сообщения&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;publish&lt;/code&gt; для публикация своего сообщения&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serve&lt;/code&gt; для локального запуска Jekyll, чтобы можно было посмотреть как выглядит мой пост в браузере&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;И мне очень нравится такой вид работы.
Я написал небольшую Java &lt;a href=&quot;/java/jekyll/2018/04/09/jekyll-boost.html&quot;&gt;программу для генерации постов по шаблону&lt;/a&gt;.
Она маленькая и простая, но позволяет значительно уменьшить время для создания сообщения и преодолеть рубеж от хочу написать пост до пишу пост.
Я думаю, что если бы не написал ее в самом начале, то не смог бы столько времени постить в свой блог.
Когда я ее писал, казалось, что Java не лучший выбор для такого рода задачи, но теперь когда она несколько месяцев работает и не требует изменений, я вполне удовлетворен выбором.
И не замечаю какая она медленная, как никак на страте запускается Java и какая она многословная, потому что она просто работает.&lt;/p&gt;

&lt;p&gt;Раньше для меня было особенно трудно после перерыва начать выполнять какие-то простые действия заново.
Например, запуск разработческого сервера.
И сильно оценил то, что догадался основные операции вынести в скрипты.
Мне достаточно зайти в папочку &lt;code class=&quot;highlighter-rouge&quot;&gt;utils&lt;/code&gt; и я найду все команды для запуска, но также и смогу посмотреть что они делают.
Это такая себе самодокументация.
Говорят, что некоторые используют make для этого и очень успешно.
Возможно мне тоже стоит прикрутить какие-нибудь средства автоматизации, но пока я даже не могу представить чем улучшить мой процесс постинга.
Большую часть времени я трачу на дело, придумывание заголовка и написание статьи.&lt;/p&gt;

&lt;p&gt;Также мне нравится писать сообщения в Vim, это мощный удобный редактор с большими возможностями. 
Например я пользуюсь проверкой орфографии и это хорошо работает.&lt;/p&gt;

&lt;p&gt;Я управляю блогом из командной строки и для меня это самый удобный способ на данный момент.
И в этом я вижу мощь командной строки.&lt;/p&gt;</content><author><name></name></author><summary type="html">Этот блог я веду с помощью системы Jekyll и размещаю на Github pages. Я делаю это где-то в течение полугода первый пост я написал 8 апреля. На Github Pages размещаются статические странички моего блога, которые генерятся с помощью Jekyll. Jekyll позволяет писать сообщения в любом текстовом редакторе. Я использую Vim. Это оказалось очень удобно, гораздо удобнее чем писать в каком-либо браузерном редакторе или писать в текстовом редакторе, а потом для постинга переносить в браузер. Для работы я завел несколько командных скриптов: new-post для создания нового сообщения publish для публикация своего сообщения serve для локального запуска Jekyll, чтобы можно было посмотреть как выглядит мой пост в браузере</summary></entry><entry><title type="html">Интересный пост о базах данных от Марка Келегана</title><link href="http://yamakarov.ru/databases/2018/09/14/mark-about-db.html" rel="alternate" type="text/html" title="Интересный пост о базах данных от Марка Келегана" /><published>2018-09-14T12:06:00+03:00</published><updated>2018-09-14T12:06:00+03:00</updated><id>http://yamakarov.ru/databases/2018/09/14/mark-about-db</id><content type="html" xml:base="http://yamakarov.ru/databases/2018/09/14/mark-about-db.html">&lt;p&gt;Очень интересный &lt;a href=&quot;http://smalldatum.blogspot.com/2018/09/review-of-slimdb-from-vldb-2018.html&quot;&gt;пост о базах данных&lt;/a&gt;.
Марк рекомендует прочитать статью про &lt;a href=&quot;http://www.vldb.org/pvldb/vol10/p2037-ren.pdf&quot;&gt;новый результаты в алгоритмах баз данных&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Дается краткое описание статьи, чтобы заинтересовать читателя в ее прочтении.
Особенно мне понравился тезис о том, что статья не должны быть идеальной, чтобы ее стоило прочитать.
Как я понял, эта статья как раз не идеальная, но ее стоить читать.
Сейчас, когда пишется огромное количество статей, прочитать все невозможно и, чтобы не пропустить важное, надо грамотно выбирать материалы для чтения.&lt;/p&gt;

&lt;p&gt;Также в сообщении Марка мне очень понравилось обилие ссылок на сопутствующие материалы.
Он дает краткие описания к статьям из списка литературы и создает целостную картину мира.
Статьи не появляются из ниоткуда, обычно они являются продолжением чьей либо работы, развитие идей или уточнение результатов.
По этой причине важно понимать что откуда берется и куда следует.&lt;/p&gt;

&lt;p&gt;Читать статьи тяжело. 
Пока я это не понял, я вообще не читал статьи, а ограничивался материалами блогов.
Однако, как я вижу и по тому, что получается у меня, читать блоги очень неэффективное занятие.
Труднее, но при этом полезнее читать статьи.
Их приходится читать по несколько раз, чтобы уложить новые идеи в своей голове.
Это признает Марк, он говорит что статья трудная и надо приложить усилия чтобы разобраться.
Я частенько сталкиваюсь с тем, что даже после нескольких прочтений не понимаю написанного.
Это по-видимому нормально, иногда надо просто идти дальше и с накоплением знаний придет и понимание.&lt;/p&gt;</content><author><name></name></author><summary type="html">Очень интересный пост о базах данных. Марк рекомендует прочитать статью про новый результаты в алгоритмах баз данных.</summary></entry></feed>