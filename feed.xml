<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://yamakarov.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="http://yamakarov.ru/" rel="alternate" type="text/html" /><updated>2018-06-27T15:32:59+03:00</updated><id>http://yamakarov.ru/</id><title type="html">Записки Java программиста</title><subtitle>Блог о разработке web админок, CRM-ок и прочего. 
</subtitle><entry><title type="html">Неполная классификация высокой нагрузки</title><link href="http://yamakarov.ru/highload/2018/06/27/highload-types.html" rel="alternate" type="text/html" title="Неполная классификация высокой нагрузки" /><published>2018-06-27T15:17:00+03:00</published><updated>2018-06-27T15:17:00+03:00</updated><id>http://yamakarov.ru/highload/2018/06/27/highload-types</id><content type="html" xml:base="http://yamakarov.ru/highload/2018/06/27/highload-types.html">&lt;p&gt;Если у вас пользовательский сервис, с социальной составляющей то скорее всего у вас будут такие высоконагруженные компоненты:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Хранение данных о пользователе&lt;/li&gt;
  &lt;li&gt;Хранение файлов пользователя, это могут быть документы, фотки или видеофайлы, которые надо хранить как есть&lt;/li&gt;
  &lt;li&gt;Поисковый сервис&lt;/li&gt;
  &lt;li&gt;Платежный сервис&lt;/li&gt;
  &lt;li&gt;Скорее всего вы захотите дать возможность пользователям писать сообщения&lt;/li&gt;
  &lt;li&gt;Также у вас могут быть разные уведомления для пользователя&lt;/li&gt;
  &lt;li&gt;Вы будете крутить рекламу и для показа баннеров тоже нужен будет сервис&lt;/li&gt;
  &lt;li&gt;Вы, конечно, захотите отслеживать и активность пользователя, проводить A/B тестирование и разную аналитику&lt;/li&gt;
  &lt;li&gt;Вся эта огромная махина будет требовать мониторинга и сбора статистики, чтобы разработчики могли вовремя реагировать&lt;/li&gt;
  &lt;li&gt;Множество программ на куче серверов будут генерить гигабайты логов, которые разработчики иногда будут читать&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Каждая компонента будет иметь специфический профиль использования. Для того, чтобы сэкономить на железе, обеспечить высокую доступность и порадовать пользователя хочется выжимать максимум из железа.
А когда больше не выжать, хочется иметь возможность залить проблему деньгами докупив еще серверов. Поэтому для каждого компонента строятся специфические решения учитывающие особенности доступа к данным, этим и объясняется огромное количество No SQL баз данных.
И выбрав правильный инструмент, можно очень сильно сэкономить и сделать доселе немыслимое.&lt;/p&gt;</content><author><name></name></author><summary type="html">Если у вас пользовательский сервис, с социальной составляющей то скорее всего у вас будут такие высоконагруженные компоненты: Хранение данных о пользователе Хранение файлов пользователя, это могут быть документы, фотки или видеофайлы, которые надо хранить как есть Поисковый сервис Платежный сервис Скорее всего вы захотите дать возможность пользователям писать сообщения Также у вас могут быть разные уведомления для пользователя Вы будете крутить рекламу и для показа баннеров тоже нужен будет сервис Вы, конечно, захотите отслеживать и активность пользователя, проводить A/B тестирование и разную аналитику Вся эта огромная махина будет требовать мониторинга и сбора статистики, чтобы разработчики могли вовремя реагировать Множество программ на куче серверов будут генерить гигабайты логов, которые разработчики иногда будут читать</summary></entry><entry><title type="html">Многозадачность и прерывания</title><link href="http://yamakarov.ru/multithreading/2018/06/26/interrupts.html" rel="alternate" type="text/html" title="Многозадачность и прерывания" /><published>2018-06-26T12:38:00+03:00</published><updated>2018-06-26T12:38:00+03:00</updated><id>http://yamakarov.ru/multithreading/2018/06/26/interrupts</id><content type="html" xml:base="http://yamakarov.ru/multithreading/2018/06/26/interrupts.html">&lt;p&gt;Процессор умеет выполнять команды.
Он делает это последовательно.
Каждая команда занимает определенное время.
Некоторые команды работают очень долго.
За это время пользователь может передумать и захотеть выполнить другую команду.
Чтобы поддержать такое поведение существует механизм прерываний.
Нажав на кнопку пользователь может послать процессору специальный сигнал.
Получив такой сигнал, процессор загрузит специальную программу, обычно это код операционной системы.
Эта программа проанализирует текущие выполняемые задачи и запрос пользователя и выполнит то, что посчитает нужным в данным момент.&lt;/p&gt;

&lt;p&gt;Не только пользователь может посылать прерывания.
Они также могут приходить от внешних устройств.
Например, с сообщением об окончании ввода вывода или поступлении новых данных по сети.
Еще одним источником прерываний, который упорядочивает работу, является таймер.
Таймер может, а в операционных системах реального времени всегда делает, шлет прерывания через определенные промежутки времени.
С помощью этого механизма можно реализовать многозадачность на системах с одним процессором.
Тогда каждой задаче будет выделяться определенное, довольно короткое время, на выполнение.
Это отрезок называется квантом и по окончании кванта операционная система решает, какой процесс выполнять дальше.&lt;/p&gt;</content><author><name></name></author><summary type="html">Процессор умеет выполнять команды. Он делает это последовательно. Каждая команда занимает определенное время. Некоторые команды работают очень долго. За это время пользователь может передумать и захотеть выполнить другую команду. Чтобы поддержать такое поведение существует механизм прерываний. Нажав на кнопку пользователь может послать процессору специальный сигнал. Получив такой сигнал, процессор загрузит специальную программу, обычно это код операционной системы. Эта программа проанализирует текущие выполняемые задачи и запрос пользователя и выполнит то, что посчитает нужным в данным момент.</summary></entry><entry><title type="html">Язык программирования Forth</title><link href="http://yamakarov.ru/forth/2018/06/21/fort-materials.html" rel="alternate" type="text/html" title="Язык программирования Forth" /><published>2018-06-21T09:12:00+03:00</published><updated>2018-06-21T09:12:00+03:00</updated><id>http://yamakarov.ru/forth/2018/06/21/fort-materials</id><content type="html" xml:base="http://yamakarov.ru/forth/2018/06/21/fort-materials.html">&lt;p&gt;Есть такой замечательный язык &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A4%D0%BE%D1%80%D1%82_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)&quot;&gt;Forth&lt;/a&gt;.
Написал его настоящий мужик &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D1%80,_%D0%A7%D0%B0%D1%80%D0%BB%D1%8C%D0%B7_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%81%D1%82)&quot;&gt;Чарльз Мур&lt;/a&gt;, который родился в эпоху
когда мужчины сами писали драйверы устройств(&lt;a href=&quot;https://ru.wikiquote.org/wiki/%D0%9B%D0%B8%D0%BD%D1%83%D1%81_%D0%A2%D0%BE%D1%80%D0%B2%D0%B0%D0%BB%D1%8C%D0%B4%D1%81&quot;&gt;Торвальдс&lt;/a&gt;).
Forth славится своей возможностью очень быстро переходить от машинных команд к высокоуровневым концепциям.
И у меня есть задумка написать свой компилятор Forth c &lt;a href=&quot;http://lurkmore.to/%D0%91%D0%BB%D1%8D%D0%BA%D0%B4%D0%B6%D0%B5%D0%BA_%D0%B8_%D1%88%D0%BB%D1%8E%D1%85%D0%B8&quot;&gt;карамболем и профурсетками&lt;/a&gt;, чтобы лучше разобраться в устройстве компьютера.
Такое проделывали многие, например &lt;a href=&quot;https://rwmj.wordpress.com/2010/08/07/jonesforth-git-repository/&quot;&gt;Richard Jones&lt;/a&gt;.
Есть &lt;a href=&quot;https://github.com/nornagon/jonesforth&quot;&gt;репозиторий на Github&lt;/a&gt;, а сам тьюториал в файле &lt;a href=&quot;https://github.com/nornagon/jonesforth/blob/master/jonesforth.S&quot;&gt;jonesforth.S&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Есть такой замечательный язык Forth. Написал его настоящий мужик Чарльз Мур, который родился в эпоху когда мужчины сами писали драйверы устройств(Торвальдс). Forth славится своей возможностью очень быстро переходить от машинных команд к высокоуровневым концепциям. И у меня есть задумка написать свой компилятор Forth c карамболем и профурсетками, чтобы лучше разобраться в устройстве компьютера. Такое проделывали многие, например Richard Jones. Есть репозиторий на Github, а сам тьюториал в файле jonesforth.S</summary></entry><entry><title type="html">Использование off-heap памяти в Java</title><link href="http://yamakarov.ru/java/2018/06/20/off-heap-java.html" rel="alternate" type="text/html" title="Использование off-heap памяти в Java" /><published>2018-06-20T14:18:00+03:00</published><updated>2018-06-20T14:18:00+03:00</updated><id>http://yamakarov.ru/java/2018/06/20/off-heap-java</id><content type="html" xml:base="http://yamakarov.ru/java/2018/06/20/off-heap-java.html">&lt;p&gt;&lt;a href=&quot;https://mechanical-sympathy.blogspot.com/2012/10/compact-off-heap-structurestuples-in.html&quot;&gt;Compact Off-Heap Structures/Tuples In Java&lt;/a&gt; - интересный пост, показывающий как легко и непринужденно можно было работать с памятью вне кучи с использованием &lt;a href=&quot;https://anton-arhipov.livejournal.com/264843.html&quot;&gt;Unsafe&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Compact Off-Heap Structures/Tuples In Java - интересный пост, показывающий как легко и непринужденно можно было работать с памятью вне кучи с использованием Unsafe</summary></entry><entry><title type="html">Процессорный кэш</title><link href="http://yamakarov.ru/processor/cache/2018/06/19/processor-cache.html" rel="alternate" type="text/html" title="Процессорный кэш" /><published>2018-06-19T14:45:00+03:00</published><updated>2018-06-19T14:45:00+03:00</updated><id>http://yamakarov.ru/processor/cache/2018/06/19/processor-cache</id><content type="html" xml:base="http://yamakarov.ru/processor/cache/2018/06/19/processor-cache.html">&lt;p&gt;Современные процессоры очень быстро работают.
Они умеют:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;одновременно выполнять несколько операций, это называется конвейерезацией.&lt;/li&gt;
  &lt;li&gt;автоматически распаралеливать выполнение независимых операций, это называется суперскалярностью.&lt;/li&gt;
  &lt;li&gt;переставлять операции местами, чтобы увеличить пропускную способность конвейера&lt;/li&gt;
  &lt;li&gt;делать спекулятивное выполнение и потом отбрасывать результат&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Это очень круто и очень мощно.
Но есть проблема. 
Очень часто нужно считать данные из памяти, а потом записать результат в память. 
Это не распаралеливается.
А память медленная отчасти из-за растояния до процессора, от того что конденсаторы не могут мгновенно разрядиться и т.д.
В зависимости от устройства доступ к памяти занимает от 20 до 100 тактов процессора.
Очень долго!&lt;/p&gt;

&lt;p&gt;Стандартное решение такой задачи это кэширование. 
И мы кэшируем, где можем, сколько можем и когда можем.
Со следующими ограничениями на всех уровнях. 
Чем больше кэш, тем дольше к нему доступ. Это следствие физических ограничений, все быстрое потребляет много энергии, и плотность размещения элементов ограничена.&lt;/p&gt;</content><author><name></name></author><summary type="html">Современные процессоры очень быстро работают. Они умеют: одновременно выполнять несколько операций, это называется конвейерезацией. автоматически распаралеливать выполнение независимых операций, это называется суперскалярностью. переставлять операции местами, чтобы увеличить пропускную способность конвейера делать спекулятивное выполнение и потом отбрасывать результат</summary></entry><entry><title type="html">Теоретически некоторые программисты достигают этого минимума</title><link href="http://yamakarov.ru/cs/2018/06/18/theoretical-min.html" rel="alternate" type="text/html" title="Теоретически некоторые программисты достигают этого минимума" /><published>2018-06-18T15:14:00+03:00</published><updated>2018-06-18T15:14:00+03:00</updated><id>http://yamakarov.ru/cs/2018/06/18/theoretical-min</id><content type="html" xml:base="http://yamakarov.ru/cs/2018/06/18/theoretical-min.html">&lt;p&gt;&lt;a href=&quot;https://sharpc.livejournal.com/67583.html&quot;&gt;Теоретический минимум для программиста&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Теоретический минимум для программиста</summary></entry><entry><title type="html">RISC и x86</title><link href="http://yamakarov.ru/x86/risc/2018/06/15/x86-risc.html" rel="alternate" type="text/html" title="RISC и x86" /><published>2018-06-15T15:01:00+03:00</published><updated>2018-06-15T15:01:00+03:00</updated><id>http://yamakarov.ru/x86/risc/2018/06/15/x86-risc</id><content type="html" xml:base="http://yamakarov.ru/x86/risc/2018/06/15/x86-risc.html">&lt;p&gt;Оказывается современные x86 процессоры работают как конвейерные суперскаляры.
Для этого они декодируют инструкции ассемблера в микрокоманды примерно по такой схеме:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://yamakarov.ru/img/riscyx862.svg&quot; alt=&quot;CISC инструкции ассемблера в RISC микрокоманды&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Оказывается современные x86 процессоры работают как конвейерные суперскаляры. Для этого они декодируют инструкции ассемблера в микрокоманды примерно по такой схеме:</summary></entry><entry><title type="html">Интересное введение в архитектуру современных процессоров</title><link href="http://yamakarov.ru/hardware/2018/06/14/modern-processors.html" rel="alternate" type="text/html" title="Интересное введение в архитектуру современных процессоров" /><published>2018-06-14T15:12:00+03:00</published><updated>2018-06-14T15:12:00+03:00</updated><id>http://yamakarov.ru/hardware/2018/06/14/modern-processors</id><content type="html" xml:base="http://yamakarov.ru/hardware/2018/06/14/modern-processors.html">&lt;p&gt;&lt;a href=&quot;http://www.lighterra.com/papers/modernmicroprocessors/&quot;&gt;Modern Microprocessors. A 90-Minute Guide!&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Modern Microprocessors. A 90-Minute Guide!</summary></entry><entry><title type="html">Регистры в архитектуре x86-64</title><link href="http://yamakarov.ru/x86_64/2018/06/14/registers.html" rel="alternate" type="text/html" title="Регистры в архитектуре x86-64" /><published>2018-06-14T09:56:00+03:00</published><updated>2018-06-14T09:56:00+03:00</updated><id>http://yamakarov.ru/x86_64/2018/06/14/registers</id><content type="html" xml:base="http://yamakarov.ru/x86_64/2018/06/14/registers.html">&lt;p&gt;В архитектуре &lt;a href=&quot;https://ru.wikipedia.org/wiki/X86-64&quot;&gt;x86-64&lt;/a&gt; существуют следующие &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80_%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%BE%D1%80%D0%B0&quot;&gt;регистры&lt;/a&gt; общего назначения:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RAX - аккумулятор, потому что в него часть инструкций складывает результат выполнения&lt;/li&gt;
  &lt;li&gt;RBX - инструкции используют как адрес начала данных&lt;/li&gt;
  &lt;li&gt;RCX - используется в качестве счетчика цикла и автоматически уменьшается рядом команд&lt;/li&gt;
  &lt;li&gt;RDX - регистр данных, по-видимому можно использовать для чего угодно и специального назначения не имеет&lt;/li&gt;
  &lt;li&gt;RSI - источник, адрес в памяти для получения данных&lt;/li&gt;
  &lt;li&gt;RDI - получатель, адрес в памяти куда записываются данные&lt;/li&gt;
  &lt;li&gt;RBP - регистр базы кадра стека для организации вызова функций&lt;/li&gt;
  &lt;li&gt;RSP - регистр указателя стека для определения места в памяти где начинается стек&lt;/li&gt;
  &lt;li&gt;R8-R15 - неименованные и могут использоваться для различных операций&lt;/li&gt;
  &lt;li&gt;RFLAGS - регистр флагов с разными полезными битами&lt;/li&gt;
  &lt;li&gt;RIP - содержит адрес текущий выполняемой команды, и данные сюда заносить не надо, это делает сам процессор при выполнении операций перехода&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">В архитектуре x86-64 существуют следующие регистры общего назначения:</summary></entry><entry><title type="html">Отимизация ассемблерного кода</title><link href="http://yamakarov.ru/assembler/2018/06/13/assembler-optimisations.html" rel="alternate" type="text/html" title="Отимизация ассемблерного кода" /><published>2018-06-13T12:46:00+03:00</published><updated>2018-06-13T12:46:00+03:00</updated><id>http://yamakarov.ru/assembler/2018/06/13/assembler-optimisations</id><content type="html" xml:base="http://yamakarov.ru/assembler/2018/06/13/assembler-optimisations.html">&lt;p&gt;Хочу поделиться ресурсами, которые мне понравились в процессе изучения ассемблера:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.stolyarov.info/books/asm_unix&quot;&gt;Программирование на языке ассемблера NASM для ОС Unix&lt;/a&gt; - доступным языком описаны основы программирования на ассемблере под Linux. 
Это пособие. Автор также выпустил серию книг &lt;a href=&quot;http://www.stolyarov.info/books/programming_intro&quot;&gt;Программирование: Введение в профессию&lt;/a&gt;, в которую входит материал из пособия.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.agner.org/optimize&quot;&gt;Сайт Agner Fog&lt;/a&gt; здесь большое колчичество материалов по оптимизации ассемблерного кода и в отличии от &lt;a href=&quot;https://software.intel.com/en-us/download/intel-64-and-ia-32-architectures-sdm-combined-volumes-1-2a-2b-2c-2d-3a-3b-3c-3d-and-4&quot;&gt;Intel руководства&lt;/a&gt; подробно разбираются прикладные вещи, то что трудно понять из сухого описания процессорных команд&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Хочу поделиться ресурсами, которые мне понравились в процессе изучения ассемблера: Программирование на языке ассемблера NASM для ОС Unix - доступным языком описаны основы программирования на ассемблере под Linux. Это пособие. Автор также выпустил серию книг Программирование: Введение в профессию, в которую входит материал из пособия. Сайт Agner Fog здесь большое колчичество материалов по оптимизации ассемблерного кода и в отличии от Intel руководства подробно разбираются прикладные вещи, то что трудно понять из сухого описания процессорных команд</summary></entry></feed>