<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://yamakarov.ru/feed.xml" rel="self" type="application/atom+xml" /><link href="http://yamakarov.ru/" rel="alternate" type="text/html" /><updated>2018-09-24T18:45:32+03:00</updated><id>http://yamakarov.ru/</id><title type="html">Записки Java программиста</title><subtitle>Блог о разработке web админок, CRM-ок и прочего. 
</subtitle><entry><title type="html">Работа программиста</title><link href="http://yamakarov.ru/software/2018/09/24/programmer-job.html" rel="alternate" type="text/html" title="Работа программиста" /><published>2018-09-24T18:26:00+03:00</published><updated>2018-09-24T18:26:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/24/programmer-job</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/24/programmer-job.html">&lt;p&gt;Я довольно долго занимаюсь написание программ.
Уже лет 20 точно.
И только недавно осознал, как писать надежные программы.
Это банально, но чтобы программа не содержала ошибок, надо рассмотреть все возможные входные данные и доказать что определенные свойства будут выполнены.
Сейчас я так не делаю, я пишу программу и начинаю тестировать.
Тестирование выявляет проблемы, которые я правлю и продолжаю тестирование.
Поэтому я посредственный программист.&lt;/p&gt;

&lt;p&gt;У меня есть одно небольшое оправдание.
В книгах о технологиях обычно опускается разбор краевых случаев и обработка ошибок.
Эти вещи существенно увеличивают кодовую базу и отвлекают читателя от главной идеи, затрудняя ее понимание.
Поэтому по книжкам трудно научиться промышленному программированию.&lt;/p&gt;

&lt;p&gt;Но и в процессе работы, учиться хорошим практиками довольно тяжело.
Большое количество софта имеет очень низкие требования к качеству.
Часто нужно, чтобы оно хоть как-то работало, а люди уж смогут приспособиться и обходить ошибки в программе.
Во всяком случае, я умудрился 15 лет писать программное обеспечение и ни разу не видел, чтобы проекты провалились из-за низкого качества.
Но то моя специфика, возможно в космической, финансовой и медицинской сферах по другому.
Хотя, насколько я знаю, доказательное программирование повсеместно заменяется более тщательным тестированием.
Чем больше тестируешь, тем меньше багов останется.
Главное, чтобы фиксы багов не плодили новых багов.
А то бывают программисты у которых этот процесс не сходится, ну или очень медленно сходится.&lt;/p&gt;

&lt;p&gt;Есть простые вещи. 
Например, раньше я бывало писал бесконечные циклы.
Но с тех, пор как я узнал что существуют инварианты циклов и стал в цикле сначала писать уменьшение переменной цикла, а потом уже тело цикла, это проблема почти мне не встречается.&lt;/p&gt;

&lt;p&gt;А вот с NPE я так и не поборолся, они регулярно выскакивают в моем коде.
Хотя кажется, чего уж проще. 
Можно расставить аннотации и заставить IDE проверять на возможное null значение.&lt;/p&gt;

&lt;p&gt;Интересной концепцией для формулирования свойств программы особенно в пользовательском интерфейсе, мне кажется идея состояний.
Когда пишется компонент, надо сформулировать набор состояний в которых он может прибывать.
Дальше по осуществлению тех или иных событий фиксировать переходы из одного состояния в другое.
Если к каждому состоянию привязать состояние входящих компонент, мы получим консистентное состояние системы.&lt;/p&gt;</content><author><name></name></author><summary type="html">Я довольно долго занимаюсь написание программ. Уже лет 20 точно. И только недавно осознал, как писать надежные программы. Это банально, но чтобы программа не содержала ошибок, надо рассмотреть все возможные входные данные и доказать что определенные свойства будут выполнены. Сейчас я так не делаю, я пишу программу и начинаю тестировать. Тестирование выявляет проблемы, которые я правлю и продолжаю тестирование. Поэтому я посредственный программист.</summary></entry><entry><title type="html">Опыт в программировании</title><link href="http://yamakarov.ru/software/2018/09/21/programming-experience.html" rel="alternate" type="text/html" title="Опыт в программировании" /><published>2018-09-21T18:16:00+03:00</published><updated>2018-09-21T18:16:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/21/programming-experience</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/21/programming-experience.html">&lt;p&gt;Мне как взрослеющему или даже стареющему программисту приходится задумываться о том, чем я лучше молодых программистов.
И лучше ли на самом деле.
Есть определенный круг задач, с которыми я справляюсь очень плохо.
Это некие рутинные работы, повторение того, что уже было когда-то сделано.
И я плохо решаю супер сложные задания, в которых требуется высокая концентрация и есть большой риск неудачи.
Хорошо мне даются средней сложности задачи, желательно чтобы что-то подобные я уже делал раньше.
Может быть поэтому я и занимаюсь админками.
Они очень похожи друг на друга, и если хочется то можно пытаться автоматизировать рутинную работу.&lt;/p&gt;

&lt;p&gt;Смотря на молодых разработчиков, я вижу у них следующие недостатки:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Они могут просто не знать о некоторых областях программирования. 
Например я встречался с тем, что хорошие молодые разработчики совершенно ничего не знают про SQL, и там где можно решить задачу одной строчкой городят целый лес.
Или наоборот пишут многоэтажный SQL там где хорошо бы этого не делать, чтобы не размазывать логику и не нагружать базу данных. 
Наверное, это относится к кругозору и общей начитанности и до определенного времени просто нельзя разобраться во всех необходимых областях.
На мой взгляд при должном старании на устранения этого недостатка требуется 3-5 лет.&lt;/li&gt;
  &lt;li&gt;Молодые разработчики могут не уметь работать в команде.
Просто не понимают, как правильно взаимодействовать с начальством и коллегами. 
Тут может потребоваться довольно много времени на то, чтобы овладеть этим навыками. 
Это может приводить к частой смене работы.
Может никогда не закончиться, а может человек этому научится еще в детском саду или школе или институте.&lt;/li&gt;
  &lt;li&gt;Неопытные разработчики могут быть крайне самонадеянны, но не факт что это недостаток. 
Некоторые задачи требуют определенного уровня безответственности, чрезмерной самоуверенности.
Но таких задач мало.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Но у начинающих программистов есть и очевидные достоинства:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Часто они очень быстро соображают. В свои 37 я начал замечать замедленее в соображалке. 
В первый раз я это осознал, когда долго и вдумчиво читал инструкцию к лифту. 
Раньше со мной такого не было.&lt;/li&gt;
  &lt;li&gt;Они открыты всему новому, легче испытывают энтузиазм по поводу новых технологий. 
При &lt;a href=&quot;/software/2018/09/12/hipster-tech.html&quot;&gt;чрезмерном употреблении&lt;/a&gt; это может приводить к проблемам. 
Но дозировано помогает освоить новый материал.&lt;/li&gt;
  &lt;li&gt;В зависимости от ситуации большим плюсом может быть их управляемость. 
Частенько менеджеру гораздо проще общаться с молодыми специалистами.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Все это довольно общие замечания.
Конкретно, я бы хотел добавить, что очень важным для программиста является владение методами.
Важно иметь в своим арсенале множество способов решения задачи, чтобы из них можно было выбрать.
Насколько я понимаю, овладение одним методом ведет к упрощению овладения другим.
Поэтому достаточно интересные результаты получаются у людей в любом возрасте.
И к сожалению, люди часто останавливаются в этом процессе.
Находят один способ и успокаиваются, огорчаются лишь тогда когда метод перестает работать, а новый освоить очень сложно.&lt;/p&gt;</content><author><name></name></author><summary type="html">Мне как взрослеющему или даже стареющему программисту приходится задумываться о том, чем я лучше молодых программистов. И лучше ли на самом деле. Есть определенный круг задач, с которыми я справляюсь очень плохо. Это некие рутинные работы, повторение того, что уже было когда-то сделано. И я плохо решаю супер сложные задания, в которых требуется высокая концентрация и есть большой риск неудачи. Хорошо мне даются средней сложности задачи, желательно чтобы что-то подобные я уже делал раньше. Может быть поэтому я и занимаюсь админками. Они очень похожи друг на друга, и если хочется то можно пытаться автоматизировать рутинную работу.</summary></entry><entry><title type="html">Сроки разработки</title><link href="http://yamakarov.ru/software/2018/09/20/development-time.html" rel="alternate" type="text/html" title="Сроки разработки" /><published>2018-09-20T19:34:00+03:00</published><updated>2018-09-20T19:34:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/20/development-time</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/20/development-time.html">&lt;p&gt;Человеческая жизнь ограничена.
И люди могут достичь конечное количество целей.
Может быть с этим связано то, что мы хотим знать когда та или иная работа закончится.&lt;/p&gt;

&lt;p&gt;Достижение каких-то целей легко оценить.
Например легко оценить сколько времени у вас займет поход в парикмахерскую.
Хотя и тут бывают казусы.
Очень сложно оценить сколько времени будет идти строительство.
В процессе часто появляются новые данные, которые смещают сроки сдачи.&lt;/p&gt;

&lt;p&gt;В программировании оценить сроки очень сложно.
Есть несколько причин затягивания сроков:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Добавление требований в процессе разработки&lt;/li&gt;
  &lt;li&gt;Появление новых знаний о предмете&lt;/li&gt;
  &lt;li&gt;Интеграция с другими сервисами&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Начнем с добавления новых требований. 
Ведь что такое программирование? 
Это полная детализация задачи, так чтобы ее мог выполнить компьютер.
Человек легко справляется со многими задачами, даже не понимая как он это делает.
Мы очень часто руководствуемся декларативным целеуказанием.
Человеку достаточно знать, что надо купить билет.
Компьютер же уже нужен подробный план действий вплоть до мельчайших подробностей, транзисторов и битиков летящих по проводам.
И поэтому когда заказчик выдвигает требование, он может не осознать степень декларативности своих указаний.
В процессе разработки это конечно всплывет и окажется, что такая простая для человека задача, как купить билет, для компьютера практически невыполнима.
И тогда приходится как-то ее решать уточнять и рассматривать частные случаи, что не всегда устраивает заказчика и он требует переделать, а это и ведет к расширению требований.&lt;/p&gt;

&lt;p&gt;Связано с этим и расширение знаний о предмете, декларативные знания переходят в императивные и иногда так получается, что тонкий нюанс увеличивает время разработки на порядки.
Хорошо, когда разработчик внимателен к деталям и может построить императивный план достаточно близкий к реальности.
У меня с этим совсем туго, частенько я поверхностно оцениваю декларативное описание задачи.
Итеративная разработка очень помогает решить проблему, после каждой итерации программы становятся все более подробными и в конце концов можно точно оценить сроки следующей итерации.&lt;/p&gt;

&lt;p&gt;Третий пункт также упирается в недостаточность знаний о предмете.
По-моему, так называемый “кровавый энтерпрайз” кровавый, потому что требует взаимодействия со многими внешними системами, с плохой документацией и кучей багов.
Когда пишется ПО для взаимодействия со внешней системой, для это внешней системы строится модель.
Эта модель может очень сильно отличаться от реальности и это приводит к необходимости сильно переделывать программу.&lt;/p&gt;

&lt;p&gt;Надо отчетливо понимать степень декларативности текущего алгоритма решения задачи, и там где все крайне абстрактно быть крайне осторожным.&lt;/p&gt;</content><author><name></name></author><summary type="html">Человеческая жизнь ограничена. И люди могут достичь конечное количество целей. Может быть с этим связано то, что мы хотим знать когда та или иная работа закончится.</summary></entry><entry><title type="html">Выдающиеся люди в программировании</title><link href="http://yamakarov.ru/software/2018/09/19/outstanding-people.html" rel="alternate" type="text/html" title="Выдающиеся люди в программировании" /><published>2018-09-19T18:25:00+03:00</published><updated>2018-09-19T18:25:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/19/outstanding-people</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/19/outstanding-people.html">&lt;p&gt;Для меня люди двигающие науку программирования вперед были всегда непостижимы.
Я совсем не понимал, как у них получается делать такие крутые штуки.
Теперь я начал немного понимать, как у них это получается.&lt;/p&gt;

&lt;p&gt;Для того, чтобы написать что-то интересное надо иметь светлый ум и большие знания.
Со светлым умом, кому-то повезло, кому-то нет. 
Каждому приходится жить с тем, чем наградила его природа.
Вроде как даже с очень ограниченными мозгами, при достаточной концентрации и упертости можно много чего сделать.
Главное отбросить все лишние, что не у всех получается.
Тут я не уверен в диагнозе, но кажется одержимость идеей и легкая форма шизофрении очень кстати.&lt;/p&gt;

&lt;p&gt;Знания копятся в процессе обучения. 
Самый хороший способ это получать знания от наставника, он поможет решить трудные но не важные проблемы на старте.
Наставник даст направление и укажет материалы, которые необходимо освоить.
Также поддержит в трудную минуту и скорректирует путь.
Лично мне не удалось найти наставника и я стараюсь черпать знания из книг.
Такой способ хорош, при системном подходе, который опять же так может дать наставник, но бессистемное чтение приводит к отрывочным знаниям и неэффективной трате времени.&lt;/p&gt;

&lt;p&gt;Книги хорошо тем, что дают обзор проблемы, а особенно хорошие книги как SICP просто кладезь мудрости на каждой странице.
Большое количество книг содержат довольно много воды, и если вы уже в теми читать их долго и скучно.
Гораздо интереснее читать статьи.&lt;/p&gt;

&lt;p&gt;Но с ними есть определенная сложность. 
Читать все подряд не слишком эффективно. 
Огромное количество статей ни о чем и написаны плохо.
Бывают статьи об интересном достижении, но написана так непонятно, что нет никакой возможности разобраться.
Но в целом это, пожалуй, единственный способ держать руку на пульсе.
Те материалы, которые попали в книги, или уже даже книги переведенные на русский, часто глубоко устарели.
На основе этих данных очень трудно создать что-то новое, все простое уже давно в своих статьях описали последователи, которые почерпнули знания из статей.&lt;/p&gt;

&lt;p&gt;Однако, знания это не все что требуется и не только из статей их можно получать. 
Я уже говорил про наставника - это пример человеческого взаимодействия.
Взаимодействовать можно и в более широком смысле.
Нужно общаться с другими людьми в этой области.
Часто у людей просто нет времени реализовать ту или иную хорошую идею.
Они могут ей только поделиться.
Эту идею можно подхватить развить и отрецензировать.&lt;/p&gt;

&lt;p&gt;Подводя итог, чтобы сделать что-то великое в программировании, нужно много читать, много писать и общаться с великими. 
Читать чтобы знать, писать чтобы получать фидбек, общаться чтобы были идеи.
В принципе, читать и писать достаточно, это уже и есть общение.&lt;/p&gt;</content><author><name></name></author><summary type="html">Для меня люди двигающие науку программирования вперед были всегда непостижимы. Я совсем не понимал, как у них получается делать такие крутые штуки. Теперь я начал немного понимать, как у них это получается.</summary></entry><entry><title type="html">Angular во внутренней разработке</title><link href="http://yamakarov.ru/angular/2018/09/18/angular-pitfalls.html" rel="alternate" type="text/html" title="Angular во внутренней разработке" /><published>2018-09-18T18:13:00+03:00</published><updated>2018-09-18T18:13:00+03:00</updated><id>http://yamakarov.ru/angular/2018/09/18/angular-pitfalls</id><content type="html" xml:base="http://yamakarov.ru/angular/2018/09/18/angular-pitfalls.html">&lt;p&gt;Для внутренней фронтенд разработки мы используем &lt;a href=&quot;https://angular.io/&quot;&gt;Angular&lt;/a&gt;.
Это отличный фреймворк, который существенно ускоряет разработку.
В связке с &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;Typescript&lt;/a&gt; он становится еще мощнее.&lt;/p&gt;

&lt;p&gt;Преимуществом Angular является то, что на нем очень удобно делать компоненты и управлять состоянием.
Идея отслеживать изменения модели и автоматически перерисовывать представление оказывается очень мощной.
Ею легко овладеть.
Несмотря на то, что порог вхождения считается довольно высоким из моего получается, что это не так.
У одного и того же разработчика, на jQuery и Angular получаются очень разные по функциональности компоненты.&lt;/p&gt;

&lt;p&gt;Скажем так, что на jQuery они вообще не получаются, на выходе месиво из разных функций, беспорядочно вызываемых.
В то же время на Angular все разбито на компоненты и более менее упорядочено.&lt;/p&gt;

&lt;p&gt;Но кое за что мне хочется поругать Angular.
В нем довольно сложно переиспользовать компоненты.
Из-за того, что фреймворк нещадно смешивает html и код приложения, трудно отделить верстку от бизнес логики.
И мои приложения получаются сборником довольно разувесистых компонент, которые совсем не комбинируются друг с другом, 
а просто являются отдельными страницами приложения.&lt;/p&gt;

&lt;p&gt;В этом плане мне нравится идея, так сказать перенести рендеринг на сервер.
Там можно строить тот же виртуальный дом, что строится на клиенте при изменении модели и отправлять назад в браузер.
Клиентскому коду останется только собирать ввод пользователя, отправлять на сервер и подставлять в реальный dom, dom отрендаренный на сервере.&lt;/p&gt;

&lt;p&gt;Что это даст?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Клиент будет содержать минимальную, хотя и довольно сложную логику&lt;/li&gt;
  &lt;li&gt;Все компоненты будут строиться, а значит и тестироваться на сервере, тут можно возразить, что тестировать можно и клиентский Angular, но иметь два фреймворка для тестирования хуже чем один и потому тестировать на сервере мне видится проще&lt;/li&gt;
  &lt;li&gt;Такой подход удобен для индексации поисковиками, хотя это и не случай внутренней разработки&lt;/li&gt;
  &lt;li&gt;При генерации html серверными функциями можно пользоваться всею мощью любимой IDE&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Для внутренней фронтенд разработки мы используем Angular. Это отличный фреймворк, который существенно ускоряет разработку. В связке с Typescript он становится еще мощнее.</summary></entry><entry><title type="html">Мощь командной строки</title><link href="http://yamakarov.ru/commandline/2018/09/17/command-line-power.html" rel="alternate" type="text/html" title="Мощь командной строки" /><published>2018-09-17T17:38:00+03:00</published><updated>2018-09-17T17:38:00+03:00</updated><id>http://yamakarov.ru/commandline/2018/09/17/command-line-power</id><content type="html" xml:base="http://yamakarov.ru/commandline/2018/09/17/command-line-power.html">&lt;p&gt;Этот блог я веду с помощью системы &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; и размещаю на &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github pages&lt;/a&gt;.
Я делаю это где-то в течение полугода &lt;a href=&quot;/kotlin/2018/04/08/kotlin-coroutines.html&quot;&gt;первый пост&lt;/a&gt; я написал 8 апреля.
На Github Pages размещаются статические странички моего блога, которые генерятся с помощью Jekyll.
Jekyll позволяет писать сообщения в любом текстовом редакторе.
Я использую Vim.
Это оказалось очень удобно, гораздо удобнее чем писать в каком-либо браузерном редакторе или писать в текстовом редакторе, а потом для постинга переносить в браузер.
Для работы я завел несколько командных скриптов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;new-post&lt;/code&gt; для создания нового сообщения&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;publish&lt;/code&gt; для публикация своего сообщения&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;serve&lt;/code&gt; для локального запуска Jekyll, чтобы можно было посмотреть как выглядит мой пост в браузере&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;И мне очень нравится такой вид работы.
Я написал небольшую Java &lt;a href=&quot;/java/jekyll/2018/04/09/jekyll-boost.html&quot;&gt;программу для генерации постов по шаблону&lt;/a&gt;.
Она маленькая и простая, но позволяет значительно уменьшить время для создания сообщения и преодолеть рубеж от хочу написать пост до пишу пост.
Я думаю, что если бы не написал ее в самом начале, то не смог бы столько времени постить в свой блог.
Когда я ее писал, казалось, что Java не лучший выбор для такого рода задачи, но теперь когда она несколько месяцев работает и не требует изменений, я вполне удовлетворен выбором.
И не замечаю какая она медленная, как никак на страте запускается Java и какая она многословная, потому что она просто работает.&lt;/p&gt;

&lt;p&gt;Раньше для меня было особенно трудно после перерыва начать выполнять какие-то простые действия заново.
Например, запуск разработческого сервера.
И сильно оценил то, что догадался основные операции вынести в скрипты.
Мне достаточно зайти в папочку &lt;code class=&quot;highlighter-rouge&quot;&gt;utils&lt;/code&gt; и я найду все команды для запуска, но также и смогу посмотреть что они делают.
Это такая себе самодокументация.
Говорят, что некоторые используют make для этого и очень успешно.
Возможно мне тоже стоит прикрутить какие-нибудь средства автоматизации, но пока я даже не могу представить чем улучшить мой процесс постинга.
Большую часть времени я трачу на дело, придумывание заголовка и написание статьи.&lt;/p&gt;

&lt;p&gt;Также мне нравится писать сообщения в Vim, это мощный удобный редактор с большими возможностями. 
Например я пользуюсь проверкой орфографии и это хорошо работает.&lt;/p&gt;

&lt;p&gt;Я управляю блогом из командной строки и для меня это самый удобный способ на данный момент.
И в этом я вижу мощь командной строки.&lt;/p&gt;</content><author><name></name></author><summary type="html">Этот блог я веду с помощью системы Jekyll и размещаю на Github pages. Я делаю это где-то в течение полугода первый пост я написал 8 апреля. На Github Pages размещаются статические странички моего блога, которые генерятся с помощью Jekyll. Jekyll позволяет писать сообщения в любом текстовом редакторе. Я использую Vim. Это оказалось очень удобно, гораздо удобнее чем писать в каком-либо браузерном редакторе или писать в текстовом редакторе, а потом для постинга переносить в браузер. Для работы я завел несколько командных скриптов: new-post для создания нового сообщения publish для публикация своего сообщения serve для локального запуска Jekyll, чтобы можно было посмотреть как выглядит мой пост в браузере</summary></entry><entry><title type="html">Интересный пост о базах данных от Марка Келегана</title><link href="http://yamakarov.ru/databases/2018/09/14/mark-about-db.html" rel="alternate" type="text/html" title="Интересный пост о базах данных от Марка Келегана" /><published>2018-09-14T12:06:00+03:00</published><updated>2018-09-14T12:06:00+03:00</updated><id>http://yamakarov.ru/databases/2018/09/14/mark-about-db</id><content type="html" xml:base="http://yamakarov.ru/databases/2018/09/14/mark-about-db.html">&lt;p&gt;Очень интересный &lt;a href=&quot;http://smalldatum.blogspot.com/2018/09/review-of-slimdb-from-vldb-2018.html&quot;&gt;пост о базах данных&lt;/a&gt;.
Марк рекомендует прочитать статью про &lt;a href=&quot;http://www.vldb.org/pvldb/vol10/p2037-ren.pdf&quot;&gt;новый результаты в алгоритмах баз данных&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Дается краткое описание статьи, чтобы заинтересовать читателя в ее прочтении.
Особенно мне понравился тезис о том, что статья не должны быть идеальной, чтобы ее стоило прочитать.
Как я понял, эта статья как раз не идеальная, но ее стоить читать.
Сейчас, когда пишется огромное количество статей, прочитать все невозможно и, чтобы не пропустить важное, надо грамотно выбирать материалы для чтения.&lt;/p&gt;

&lt;p&gt;Также в сообщении Марка мне очень понравилось обилие ссылок на сопутствующие материалы.
Он дает краткие описания к статьям из списка литературы и создает целостную картину мира.
Статьи не появляются из ниоткуда, обычно они являются продолжением чьей либо работы, развитие идей или уточнение результатов.
По этой причине важно понимать что откуда берется и куда следует.&lt;/p&gt;

&lt;p&gt;Читать статьи тяжело. 
Пока я это не понял, я вообще не читал статьи, а ограничивался материалами блогов.
Однако, как я вижу и по тому, что получается у меня, читать блоги очень неэффективное занятие.
Труднее, но при этом полезнее читать статьи.
Их приходится читать по несколько раз, чтобы уложить новые идеи в своей голове.
Это признает Марк, он говорит что статья трудная и надо приложить усилия чтобы разобраться.
Я частенько сталкиваюсь с тем, что даже после нескольких прочтений не понимаю написанного.
Это по-видимому нормально, иногда надо просто идти дальше и с накоплением знаний придет и понимание.&lt;/p&gt;</content><author><name></name></author><summary type="html">Очень интересный пост о базах данных. Марк рекомендует прочитать статью про новый результаты в алгоритмах баз данных.</summary></entry><entry><title type="html">О сложных SQL запросах</title><link href="http://yamakarov.ru/sql/2018/09/13/complex-sql-queries.html" rel="alternate" type="text/html" title="О сложных SQL запросах" /><published>2018-09-13T19:22:00+03:00</published><updated>2018-09-13T19:22:00+03:00</updated><id>http://yamakarov.ru/sql/2018/09/13/complex-sql-queries</id><content type="html" xml:base="http://yamakarov.ru/sql/2018/09/13/complex-sql-queries.html">&lt;p&gt;SQL выразительный язык.
На нем можно писать сложные запросы, делать различного вида джойны и получать интересные результаты при минимальных усилиях.
Однако из-за того, что разработчик не имеет полного контроля над тем как выполняется запрос могут происходить очень странные вещи.
Сервер баз данных строит план запроса для того, чтобы получить данные.
Этот план очень сильно зависит от статистики собранной сервером.
Эту статистику надо держать актуальной, но об этом нередко забывают.
И на выходе мы имеем жутко неоптимальный план.&lt;/p&gt;

&lt;p&gt;В своей практике я столкнулся с тем, что в какой-то момент из-за изменений в статистике запросы стали выполняться на 2 порядка медленней чем это было.
Такое поведение совершенно неприемлимо в сколько-нибудь нагруженных системах с большим количеством пользователей.
Представьте, что в пик времени продаж, запрос на оформление заказа станет выполняться в 100 раз медленнее и вы потеряете 90 процентов заказов.
Эти убытки будут никак не сравнимы с теми деньгами, которые вы сэкономили на разработке благодаря выразительности SQL.
По этой причине в нагруженных системах избегают сложных запросов.
Пусть мы напишем больше кода, пусть потратим на это больше времени, пусть это будет даже работать медленнее, лишь бы это время было предсказуемо.
Мы хотим знать сколько времени займет запрос и хотим гарантий на максимальное время запроса.&lt;/p&gt;

&lt;p&gt;Отсюда идут запреты на использование джойнов и необходимость строить индексы по всем запросам.
А без джойнов вам остаются только простые селекты, а с индексами уже и не нужен особо умный оптимизатор и если он все равно когда-нибудь решит делать полный скан таблицы, вы еще вдобавок к имеющемся ограничениям накидаете хинтов.&lt;/p&gt;

&lt;p&gt;В принципе, такая картина видна не только в SQL. 
Это классическая текущая абстракция.
Разработчику в какой-то момент нужен полный контроль, и очень высоко ценятся разработчики, которые умеют этот контроль получить и использовать.
И мне все хочется найти, но пока никак не получается, реализацию идею из книги Дейта об интеграции языка программирования и языка запросов к базе данных.
И того, что я видел ближе всего к этому подобрался LINQ, на Java я ничего подобного не встречал и в текущих проектах пишу сугубо императивный код, всеми силами избегая декларативщины.&lt;/p&gt;</content><author><name></name></author><summary type="html">SQL выразительный язык. На нем можно писать сложные запросы, делать различного вида джойны и получать интересные результаты при минимальных усилиях. Однако из-за того, что разработчик не имеет полного контроля над тем как выполняется запрос могут происходить очень странные вещи. Сервер баз данных строит план запроса для того, чтобы получить данные. Этот план очень сильно зависит от статистики собранной сервером. Эту статистику надо держать актуальной, но об этом нередко забывают. И на выходе мы имеем жутко неоптимальный план.</summary></entry><entry><title type="html">Хипстерские технологии</title><link href="http://yamakarov.ru/software/2018/09/12/hipster-tech.html" rel="alternate" type="text/html" title="Хипстерские технологии" /><published>2018-09-12T18:12:00+03:00</published><updated>2018-09-12T18:12:00+03:00</updated><id>http://yamakarov.ru/software/2018/09/12/hipster-tech</id><content type="html" xml:base="http://yamakarov.ru/software/2018/09/12/hipster-tech.html">&lt;p&gt;Сложно выбрать технологии для нового проекта.
Если смотреть на типичную админку, то надо выбрать:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Базу данных, где вы будете хранить данные&lt;/li&gt;
  &lt;li&gt;Сервер приложений, то как вы будете обрабатывать данные на сервере&lt;/li&gt;
  &lt;li&gt;Браузерные технологии, Angular там или React, или все отрендарите на сервере&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Я хочу отметить два момента.
Нельзя постоянно пользоваться проверенными технологиями. 
Они имеют свойство устаревать и в какой-то момент ты понимаешь, что твоя технология безнадежно устарела, считай стала дорогой в эксплуатации.
Чтобы развивать приложение дальше, трудно найти разработчиков, от этого они дороже.
А трудно найти, потому что производительность на другой технологии выше и там платят больше, и тому подобное.&lt;/p&gt;

&lt;p&gt;Есть и другая крайность, когда в проект берется все самое новое.
Часто это все непроверенное без должной поддержки программное обеспечение, которое может быть в любой момент заброшено авторами.
Я бы брал новое, только когда очевидно, что оно приносит пользу в конкретных условиях проекта.
Можно также брать в рамках эксперимента с новой технологией.
Ни в коем случае нельзя основывать новый большой проект на новых и плохо изученных технологиях.
Иначе придется доделывать эти технологии самому.&lt;/p&gt;

&lt;p&gt;Новые непроверенные технологии я называю хипстерские. 
Именно молодые люди в виду неопытности и плохого знакомства со старыми решениями, тащат в проект новое неопробованное, плохо понимая в чем преимущество нового, кроме удовольствия от новизны.&lt;/p&gt;</content><author><name></name></author><summary type="html">Сложно выбрать технологии для нового проекта. Если смотреть на типичную админку, то надо выбрать: Базу данных, где вы будете хранить данные Сервер приложений, то как вы будете обрабатывать данные на сервере Браузерные технологии, Angular там или React, или все отрендарите на сервере</summary></entry><entry><title type="html">Kotlin: Функции</title><link href="http://yamakarov.ru/kotlin/2018/09/11/kotlin-functions.html" rel="alternate" type="text/html" title="Kotlin: Функции" /><published>2018-09-11T17:37:00+03:00</published><updated>2018-09-11T17:37:00+03:00</updated><id>http://yamakarov.ru/kotlin/2018/09/11/kotlin-functions</id><content type="html" xml:base="http://yamakarov.ru/kotlin/2018/09/11/kotlin-functions.html">&lt;p&gt;Kotlin - набирающий популярность язык от компании JetBrains.&lt;/p&gt;

&lt;p&gt;Я слышал много положительных отзывов об этом языке.&lt;/p&gt;

&lt;p&gt;Пару дней для развлечения пишу маленькие задачки на &lt;a href=&quot;https://try.kotlinlang.org/&quot;&gt;try.kotlinlang.org&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Сначала было очень непривычно и казалось, что в Kotlin нет ничего такого, ради чего надо было бы учить этот язык.
Нет мощной системы типов как в Haskell, нет макросов как в Lisp, нет полных по Тьюрингу шаблонов как в C++.
К тому же язык выполняется на JVM и ему еще надо доказывать чем он лучше Java и других сильных конкурентов, Scala и Clojure.&lt;/p&gt;

&lt;p&gt;Немного поизучав Kotlin я нашел следующие очень интересные моменты из-за которых складывается впечатления, что язык достоин внимания:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data классы очень удобно использовать в ентерпрайзе и разного рода админках&lt;/li&gt;
  &lt;li&gt;Properties всевозможных видов, позволяющие легко задавать поведение полей и кастомизировать&lt;/li&gt;
  &lt;li&gt;Очень удобное переопределение операторов полезное для написания разного рода dsl,&lt;/li&gt;
  &lt;li&gt;Множестов способов задать функцию, приятные средства для задания анонимных и лямбда функций, а так же специальные кейсы для функций, которые  имеют один аргумент или являются единственным выражением&lt;/li&gt;
  &lt;li&gt;Destructuring параметров&lt;/li&gt;
  &lt;li&gt;Возможно добавлять методы к уже существующим классам&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Это то, что с чем я столкнулся за час изучения Kotlin и те вещи которые мне очень понравились, действительно складывается впечатления, что его писали люди, желающие значительно ускорить промышленную разработку. 
Кажется, что с его помощью можно делать жестко оптимизированные решения заточенные на скорость, благодаря системе типов и плотной интеграции с JVM.
А тем кто хочет сделать гибкое решение для многих пользователей или написать прототип, должна быть полезна выразительность и динамичность языка, для этого есть поддержка.&lt;/p&gt;

&lt;p&gt;Также надо смотреть на нативный и браузерный варианты, которые позволяют переиспользовать код вне JVM окружения.&lt;/p&gt;</content><author><name></name></author><summary type="html">Kotlin - набирающий популярность язык от компании JetBrains.</summary></entry></feed>